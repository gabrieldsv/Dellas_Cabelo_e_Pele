D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Appointments.tsx
Código:
import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TextField,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  DialogContentText,
  IconButton,
  InputAdornment,
  CircularProgress,
  Snackbar,
  Alert,
  Select,
  MenuItem,
  Checkbox,
  ListItemText,
  InputLabel,
  FormControl,
  Chip,
} from '@mui/material';
import { 
  Add as AddIcon,
  Search as SearchIcon,
  Edit as EditIcon,
  CheckCircle as CheckCircleIcon,
  Cancel as CancelIcon,
  Delete as DeleteIcon,
  Phone as PhoneIcon,
  DateRange as DateRangeIcon,
} from '@mui/icons-material';
import { supabase } from '../lib/supabase';
import { useAuth } from '../context/AuthContext';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { ptBR } from 'date-fns/locale';
import { 
  startOfMonth, 
  endOfMonth, 
  startOfWeek, 
  endOfWeek, 
  startOfDay, 
  endOfDay, 
  isWithinInterval, 
  parseISO 
} from 'date-fns';

// Interfaces
interface Appointment {
  id: string;
  client_id: string;
  start_time: string;
  end_time: string;
  status: string;
  final_price: number;
  appointment_services: { 
    id: string;
    service_id: string;
    price: number;
    final_price: number;
    services?: { name: string };
  }[];
  created_by: string;
}

interface Client {
  id: string;
  name: string;
  phone: string;
}

interface Service {
  id: string;
  name: string;
  price: number;
}

export default function Appointments() {
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [clients, setClients] = useState<Client[]>([]);
  const [services, setServices] = useState<Service[]>([]);
  const [filteredAppointments, setFilteredAppointments] = useState<Appointment[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { user } = useAuth();

  const [openDialog, setOpenDialog] = useState(false);
  const [openClientDialog, setOpenClientDialog] = useState(false);
  const [openServiceDialog, setOpenServiceDialog] = useState(false);
  const [openCompleteDialog, setOpenCompleteDialog] = useState(false);
  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
  const [currentAppointment, setCurrentAppointment] = useState<Appointment | null>(null);

  const [clientId, setClientId] = useState('');
  const [appointmentServices, setAppointmentServices] = useState<string[]>([]);
  const [appointmentDate, setAppointmentDate] = useState<Date | null>(new Date());
  const [newClientName, setNewClientName] = useState('');
  const [newClientPhone, setNewClientPhone] = useState('');
  const [newServiceName, setNewServiceName] = useState('');
  const [newServicePrice, setNewServicePrice] = useState('0');
  const [finalPrices, setFinalPrices] = useState<{[key: string]: string}>({});

  const [clientSearchTerm, setClientSearchTerm] = useState('');
  const [serviceSearchTerm, setServiceSearchTerm] = useState('');
  const [filteredClients, setFilteredClients] = useState<Client[]>([]);
  const [filteredServices, setFilteredServices] = useState<Service[]>([]);

  const [startDate, setStartDate] = useState<Date | null>(startOfMonth(new Date()));
  const [endDate, setEndDate] = useState<Date | null>(endOfMonth(new Date()));
  const [dateRange, setDateRange] = useState('month');

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const [appointmentsData, clientsData, servicesData] = await Promise.all([
        supabase.from('appointments').select('*, appointment_services(id, service_id, price, final_price, services(name))').order('start_time', { ascending: false }),
        supabase.from('clients').select('*'),
        supabase.from('services').select('*')
      ]);

      if (appointmentsData.error) throw appointmentsData.error;
      if (clientsData.error) throw clientsData.error;
      if (servicesData.error) throw servicesData.error;

      // Log para depurar a quantidade de clientes carregados
      console.log('Clientes carregados:', clientsData.data);

      const sortedClients = (clientsData.data || []).sort((a, b) => a.name.localeCompare(b.name));
      setAppointments(appointmentsData.data || []);
      setFilteredAppointments(appointmentsData.data || []);
      setClients(sortedClients);
      setFilteredClients(sortedClients); // Inicializa com todos os clientes ordenados
      setServices(servicesData.data || []);
      setFilteredServices(servicesData.data || []);
    } catch (error) {
      setError('Erro ao carregar dados');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (dateRange === 'day') {
      setStartDate(startOfDay(new Date()));
      setEndDate(endOfDay(new Date()));
    } else if (dateRange === 'week') {
      setStartDate(startOfWeek(new Date(), { weekStartsOn: 0 }));
      setEndDate(endOfWeek(new Date(), { weekStartsOn: 0 }));
    } else if (dateRange === 'month') {
      setStartDate(startOfMonth(new Date()));
      setEndDate(endOfMonth(new Date()));
    }
  }, [dateRange]);

  const handleFilter = () => {
    let filtered = [...appointments];
    if (startDate && endDate) {
      filtered = filtered.filter(appointment => {
        try {
          const appointmentDate = parseISO(appointment.start_time);
          return isWithinInterval(appointmentDate, { start: startDate, end: endDate });
        } catch (error) {
          console.error('Erro ao filtrar por data:', error);
          return false;
        }
      });
    }
    if (searchTerm) {
      filtered = filtered.filter(appointment => {
        const client = clients.find(c => c.id === appointment.client_id);
        const serviceNames = appointment.appointment_services.map(as => as.services?.name || services.find(s => s.id === as.service_id)?.name || '').join(', ');
        return (
          client?.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          (client?.phone && client.phone.includes(searchTerm)) ||
          serviceNames.toLowerCase().includes(searchTerm.toLowerCase()) ||
          appointment.status.toLowerCase().includes(searchTerm.toLowerCase())
        );
      });
    }
    setFilteredAppointments(filtered);
  };

  useEffect(() => {
    handleFilter();
  }, [searchTerm, appointments, clients, services, startDate, endDate]);

  const handleFilterClients = () => {
    let filtered = [...clients];
    if (clientSearchTerm) {
      const searchTermLower = clientSearchTerm.toLowerCase();
      filtered = filtered.filter(client => 
        client.name.toLowerCase().includes(searchTermLower) ||
        (client.phone && client.phone.toLowerCase().includes(searchTermLower))
      );
    }
    filtered.sort((a, b) => a.name.localeCompare(b.name));
    setFilteredClients(filtered);
    // Log para depurar a lista filtrada
    console.log('Clientes filtrados:', filtered);
  };

  const handleFilterServices = () => {
    setFilteredServices(
      serviceSearchTerm
        ? services.filter(service => 
            service.name.toLowerCase().includes(serviceSearchTerm.toLowerCase()) ||
            service.price.toString().includes(serviceSearchTerm)
          )
        : services
    );
  };

  useEffect(() => {
    handleFilterClients();
  }, [clientSearchTerm, clients]);

  useEffect(() => {
    handleFilterServices();
  }, [serviceSearchTerm, services]);

  const handleOpenDialog = (appointment?: Appointment) => {
    if (appointment) {
      setCurrentAppointment(appointment);
      setClientId(appointment.client_id);
      setAppointmentServices(appointment.appointment_services.map(as => as.service_id));
      setAppointmentDate(new Date(appointment.start_time));
    } else {
      setCurrentAppointment(null);
      setClientId('');
      setAppointmentServices([]);
      setAppointmentDate(new Date());
    }
    setOpenDialog(true);
    setClientSearchTerm(''); // Resetar a busca ao abrir o modal
    handleFilterClients(); // Carregar todos os clientes ordenados
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
    setNewClientName('');
    setNewClientPhone('');
    setNewServiceName('');
    setNewServicePrice('0');
    setClientSearchTerm('');
    setServiceSearchTerm('');
  };

  const handleCloseClientDialog = () => setOpenClientDialog(false);
  const handleCloseServiceDialog = () => setOpenServiceDialog(false);
  const handleCloseCompleteDialog = () => {
    setOpenCompleteDialog(false);
    setFinalPrices({});
  };
  const handleOpenDeleteDialog = (appointment: Appointment) => {
    setCurrentAppointment(appointment);
    setOpenDeleteDialog(true);
  };
  const handleCloseDeleteDialog = () => setOpenDeleteDialog(false);

  const handleSaveAppointment = async () => {
    if (!clientId || appointmentServices.length === 0 || !appointmentDate) {
      setError('Todos os campos são obrigatórios');
      return;
    }
    try {
      const totalDurationMinutes = appointmentServices.length * 30;
      const startDate = new Date(appointmentDate);
      const endDate = new Date(startDate.getTime() + totalDurationMinutes * 60000);
      let appointmentId: string;

      if (currentAppointment) {
        const { error, data } = await supabase
          .from('appointments')
          .update({ client_id: clientId, start_time: startDate.toISOString(), end_time: endDate.toISOString() })
          .eq('id', currentAppointment.id)
          .select('id')
          .single();
        if (error) throw error;
        appointmentId = data.id;
      } else {
        const { error, data } = await supabase
          .from('appointments')
          .insert([{ client_id: clientId, start_time: startDate.toISOString(), end_time: endDate.toISOString(), status: 'scheduled', created_by: user?.id }])
          .select('id')
          .single();
        if (error) throw error;
        appointmentId = data.id;
      }

      await supabase.from('appointment_services').delete().eq('appointment_id', appointmentId);
      const servicesToInsert = appointmentServices.map(serviceId => ({
        appointment_id: appointmentId,
        service_id: serviceId,
        price: services.find(s => s.id === serviceId)?.price || 0,
        final_price: 0
      }));
      const { error: servicesError } = await supabase.from('appointment_services').insert(servicesToInsert);
      if (servicesError) throw servicesError;

      setSuccess('Agendamento salvo com sucesso!');
      handleCloseDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao salvar agendamento');
      console.error(error);
    }
  };

  const handleSaveNewClient = async () => {
    if (!newClientName) {
      setError('Nome é obrigatório');
      return;
    }
    try {
      const { error, data } = await supabase
        .from('clients')
        .insert([{ name: newClientName, phone: newClientPhone || null, created_by: user?.id }])
        .select('id, name, phone')
        .single();
      if (error) throw error;

      const updatedClients = [...clients, data].sort((a, b) => a.name.localeCompare(b.name));
      setClients(updatedClients);
      setFilteredClients(updatedClients);
      setClientId(data.id);
      handleCloseClientDialog();
    } catch (error) {
      setError('Erro ao adicionar novo cliente');
      console.error(error);
    }
  };

  const handleSaveNewService = async () => {
    if (!newServiceName || !newServicePrice) {
      setError('Todos os campos são obrigatórios');
      return;
    }
    if (isNaN(Number(newServicePrice)) || Number(newServicePrice) < 0) {
      setError('Preço inválido');
      return;
    }
    try {
      const { error, data } = await supabase
        .from('services')
        .insert([{ name: newServiceName, price: Number(newServicePrice), created_by: user?.id }])
        .select('id, name, price')
        .single();
      if (error) throw error;

      setServices([...services, data]);
      setFilteredServices([...filteredServices, data]);
      setAppointmentServices([...appointmentServices, data.id]);
      handleCloseServiceDialog();
    } catch (error) {
      setError('Erro ao adicionar novo serviço');
      console.error(error);
    }
  };

  const handleCompleteAppointment = (appointment: Appointment) => {
    setCurrentAppointment(appointment);
    const initialPrices: {[key: string]: string} = {};
    appointment.appointment_services.forEach(service => {
      initialPrices[service.id] = service.price.toString();
    });
    setFinalPrices(initialPrices);
    setOpenCompleteDialog(true);
  };

  const handleSaveCompletedAppointment = async () => {
    if (!currentAppointment) return;
    try {
      const totalFinalPrice = Object.values(finalPrices).reduce((sum, price) => sum + (Number(price) || 0), 0);
      const { error: appointmentError } = await supabase
        .from('appointments')
        .update({ status: 'completed', final_price: totalFinalPrice })
        .eq('id', currentAppointment.id);
      if (appointmentError) throw appointmentError;

      for (const serviceId in finalPrices) {
        const { error: serviceError } = await supabase
          .from('appointment_services')
          .update({ final_price: Number(finalPrices[serviceId]) || 0 })
          .eq('id', serviceId);
        if (serviceError) throw serviceError;
      }

      setSuccess('Agendamento finalizado com sucesso!');
      handleCloseCompleteDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao finalizar agendamento');
      console.error(error);
    }
  };

  const handleCancelAppointment = async (appointmentId: string) => {
    try {
      const { error } = await supabase
        .from('appointments')
        .update({ status: 'cancelled' })
        .eq('id', appointmentId);
      if (error) throw error;
      setSuccess('Agendamento cancelado com sucesso!');
      fetchData();
    } catch (error) {
      setError('Erro ao cancelar agendamento');
      console.error(error);
    }
  };

  const handleDeleteAppointment = async () => {
    if (!currentAppointment) return;
    try {
      setLoading(true);
      await supabase.from('appointment_services').delete().eq('appointment_id', currentAppointment.id);
      const { error: appointmentError } = await supabase
        .from('appointments')
        .delete()
        .eq('id', currentAppointment.id);
      if (appointmentError) throw appointmentError;

      setSuccess('Agendamento excluído com sucesso!');
      handleCloseDeleteDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao excluir agendamento');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  const getStatusChip = (status: string) => {
    switch (status) {
      case 'scheduled': return <Chip label="Agendado" color="primary" size="small" />;
      case 'completed': return <Chip label="Concluído" color="success" size="small" />;
      case 'cancelled': return <Chip label="Cancelado" color="error" size="small" />;
      default: return <Chip label={status} size="small" />;
    }
  };

  const handlePhoneChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let value = e.target.value.replace(/\D/g, '');
    if (value.length <= 11) {
      value = value.replace(/^(\d{2})(\d)/g, '($1) $2');
      if (value.length > 4) value = value.replace(/(\) \d)(\d{4})(\d)/, '$1 $2-$3');
      setNewClientPhone(value);
    }
  };

  const formatPhoneDisplay = (phone: string) => {
    if (!phone) return '';
    const digits = phone.replace(/\D/g, '');
    if (digits.length === 11) return `(${digits.substring(0, 2)}) ${digits.substring(2, 3)} ${digits.substring(3, 7)}-${digits.substring(7)}`;
    if (digits.length === 10) return `(${digits.substring(0, 2)}) ${digits.substring(2, 6)}-${digits.substring(6)}`;
    return phone;
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" sx={{ fontWeight: 'medium' }}>Agendamentos</Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          onClick={() => handleOpenDialog()}
          sx={{ backgroundColor: 'primary.main', '&:hover': { backgroundColor: 'primary.dark' }, borderRadius: 2 }}
        >
          Novo Agendamento
        </Button>
      </Box>

      <Paper sx={{ p: 2, mb: 3, borderRadius: 2, boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.1)', display: 'flex', flexWrap: 'wrap', gap: 2 }}>
        <TextField
          variant="outlined"
          placeholder="Buscar por nome, telefone, serviço ou status..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start" sx={{ mr: 1 }}>
                <SearchIcon sx={{ color: 'text.secondary', fontSize: '1.25rem' }} />
              </InputAdornment>
            ),
          }}
          sx={{ minWidth: 300, '& .MuiOutlinedInput-root': { borderRadius: 2 } }}
        />
        <TextField
          select
          label="Período"
          value={dateRange}
          onChange={(e) => setDateRange(e.target.value)}
          sx={{ minWidth: 150 }}
        >
          <MenuItem value="day">Hoje</MenuItem>
          <MenuItem value="week">Esta Semana</MenuItem>
          <MenuItem value="month">Este Mês</MenuItem>
          <MenuItem value="custom">Personalizado</MenuItem>
        </TextField>
        {dateRange === 'custom' && (
          <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ptBR}>
            <DatePicker 
              label="Data Inicial"
              value={startDate}
              onChange={(newValue) => setStartDate(newValue)}
              slotProps={{ textField: { size: 'small' } }}
            />
            <DatePicker 
              label="Data Final"
              value={endDate}
              onChange={(newValue) => setEndDate(newValue)}
              slotProps={{ textField: { size: 'small' } }}
            />
          </LocalizationProvider>
        )}
        <Button 
          variant="outlined" 
          onClick={fetchData}
          startIcon={<DateRangeIcon />}
          sx={{ borderRadius: 2 }}
        >
          Atualizar
        </Button>
      </Paper>

      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Cliente</TableCell>
              <TableCell>Telefone</TableCell>
              <TableCell>Serviços</TableCell>
              <TableCell>Data</TableCell>
              <TableCell>Status</TableCell>
              <TableCell align="right">Ações</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {filteredAppointments.map((appointment) => {
              const client = clients.find(c => c.id === appointment.client_id) || { name: 'Desconhecido', phone: '' };
              return (
                <TableRow key={appointment.id}>
                  <TableCell>{client.name}</TableCell>
                  <TableCell>
                    {client.phone ? (
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <PhoneIcon fontSize="small" sx={{ mr: 1, color: 'text.secondary' }} />
                        {formatPhoneDisplay(client.phone)}
                      </Box>
                    ) : (
                      <Typography variant="body2" color="text.secondary">Não informado</Typography>
                    )}
                  </TableCell>
                  <TableCell>{appointment.appointment_services.map(as => as.services?.name || services.find(s => s.id === as.service_id)?.name || '').join(', ')}</TableCell>
                  <TableCell>{new Date(appointment.start_time).toLocaleString('pt-BR')}</TableCell>
                  <TableCell>{getStatusChip(appointment.status)}</TableCell>
                  <TableCell align="right">
                    <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                      {appointment.status === 'scheduled' && (
                        <>
                          <IconButton color="success" onClick={() => handleCompleteAppointment(appointment)} size="small" sx={{ mr: 1 }}>
                            <CheckCircleIcon />
                          </IconButton>
                          <IconButton color="error" onClick={() => handleCancelAppointment(appointment.id)} size="small" sx={{ mr: 1 }}>
                            <CancelIcon />
                          </IconButton>
                        </>
                      )}
                      <IconButton color="primary" onClick={() => handleOpenDialog(appointment)} size="small" sx={{ mr: 1 }}>
                        <EditIcon />
                      </IconButton>
                      <IconButton color="error" onClick={() => handleOpenDeleteDialog(appointment)} size="small">
                        <DeleteIcon />
                      </IconButton>
                    </Box>
                  </TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>

      {/* Modal de Agendamento */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>{currentAppointment ? 'Editar Agendamento' : 'Novo Agendamento'}</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <Box sx={{ mb: 2 }}>
            <TextField
              fullWidth
              placeholder="Buscar cliente..."
              value={clientSearchTerm}
              onChange={(e) => {
                setClientSearchTerm(e.target.value);
                handleFilterClients();
              }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon fontSize="small" />
                  </InputAdornment>
                ),
              }}
              sx={{ mb: 1 }}
            />
            <FormControl fullWidth>
              <InputLabel>Cliente</InputLabel>
              <Select
                value={clientId}
                onChange={(e) => setClientId(e.target.value as string)}
                label="Cliente"
                sx={{ borderRadius: 2 }}
              >
                {filteredClients.length > 0 ? (
                  filteredClients.map(client => (
                    <MenuItem key={client.id} value={client.id}>
                      <Box>
                        <Typography variant="body1">{client.name}</Typography>
                        {client.phone && (
                          <Typography variant="caption" color="text.secondary">{formatPhoneDisplay(client.phone)}</Typography>
                        )}
                      </Box>
                    </MenuItem>
                  ))
                ) : (
                  <MenuItem disabled>Nenhum cliente encontrado</MenuItem>
                )}
              </Select>
            </FormControl>
          </Box>
          <Box sx={{ mb: 2 }}>
            <TextField
              fullWidth
              placeholder="Buscar serviço..."
              value={serviceSearchTerm}
              onChange={(e) => {
                setServiceSearchTerm(e.target.value);
                handleFilterServices();
              }}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon fontSize="small" />
                  </InputAdornment>
                ),
              }}
              sx={{ mb: 1 }}
            />
            <FormControl fullWidth>
              <InputLabel>Serviços</InputLabel>
              <Select
                multiple
                value={appointmentServices}
                onChange={(e) => setAppointmentServices(e.target.value as string[])}
                renderValue={(selected) => selected.map(id => services.find(s => s.id === id)?.name).join(', ')}
                label="Serviços"
                sx={{ borderRadius: 2 }}
              >
                {filteredServices.map(service => (
                  <MenuItem key={service.id} value={service.id}>
                    <Checkbox checked={appointmentServices.includes(service.id)} />
                    <ListItemText primary={service.name} secondary={`R$ ${service.price.toFixed(2)}`} />
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          </Box>
          <LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={ptBR}>
            <DateTimePicker
              label="Data e Hora"
              value={appointmentDate}
              onChange={(newValue) => setAppointmentDate(newValue)}
              slotProps={{ textField: { fullWidth: true, sx: { mt: 2, borderRadius: 2 } } }}
            />
          </LocalizationProvider>
        </DialogContent>
        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
          <Button onClick={handleCloseDialog} sx={{ color: 'text.secondary' }}>Cancelar</Button>
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button 
              onClick={() => setOpenClientDialog(true)} 
              variant="contained" 
              sx={{ backgroundColor: '#c8e6c9', '&:hover': { backgroundColor: '#a5d6a7' }, borderRadius: 2 }}
            >
              Adicionar Novo Cliente
            </Button>
            <Button 
              onClick={() => setOpenServiceDialog(true)} 
              variant="contained" 
              sx={{ backgroundColor: '#b3e5fc', '&:hover': { backgroundColor: '#90caf9' }, borderRadius: 2 }}
            >
              Adicionar Novo Serviço
            </Button>
            <Button 
              onClick={handleSaveAppointment} 
              variant="contained" 
              sx={{ backgroundColor: 'primary.main', '&:hover': { backgroundColor: 'primary.dark' }, borderRadius: 2 }}
            >
              Salvar
            </Button>
          </Box>
        </DialogActions>
      </Dialog>

      {/* Modal Novo Cliente */}
      <Dialog open={openClientDialog} onClose={handleCloseClientDialog} maxWidth="sm" fullWidth>
        <DialogTitle>Adicionar Novo Cliente</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <TextField
            autoFocus
            margin="dense"
            label="Nome"
            fullWidth
            value={newClientName}
            onChange={(e) => setNewClientName(e.target.value)}
            required
            sx={{ mb: 2, borderRadius: 2 }}
          />
          <TextField
            margin="dense"
            label="Telefone"
            fullWidth
            value={newClientPhone}
            onChange={handlePhoneChange}
            placeholder="(00) 0 0000-0000"
            sx={{ borderRadius: 2 }}
          />
        </DialogContent>
        <DialogActions sx={{ p: 2 }}>
          <Button onClick={handleCloseClientDialog} sx={{ color: 'text.secondary' }}>Cancelar</Button>
          <Button 
            onClick={handleSaveNewClient} 
            variant="contained" 
            sx={{ backgroundColor: 'primary.main', '&:hover': { backgroundColor: 'primary.dark' }, borderRadius: 2 }}
          >
            Salvar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Modal Novo Serviço */}
      <Dialog open={openServiceDialog} onClose={handleCloseServiceDialog} maxWidth="sm" fullWidth>
        <DialogTitle>Adicionar Novo Serviço</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <TextField
            autoFocus
            margin="dense"
            label="Nome do Serviço"
            fullWidth
            value={newServiceName}
            onChange={(e) => setNewServiceName(e.target.value)}
            required
            sx={{ mb: 2, borderRadius: 2 }}
          />
          <TextField
            margin="dense"
            label="Preço"
            type="number"
            fullWidth
            value={newServicePrice}
            onChange={(e) => setNewServicePrice(e.target.value)}
            InputProps={{ startAdornment: <InputAdornment position="start">R$</InputAdornment> }}
            sx={{ borderRadius: 2 }}
          />
        </DialogContent>
        <DialogActions sx={{ p: 2 }}>
          <Button onClick={handleCloseServiceDialog} sx={{ color: 'text.secondary' }}>Cancelar</Button>
          <Button 
            onClick={handleSaveNewService} 
            variant="contained" 
            sx={{ backgroundColor: 'primary.main', '&:hover': { backgroundColor: 'primary.dark' }, borderRadius: 2 }}
          >
            Salvar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Modal Finalizar Agendamento */}
      <Dialog open={openCompleteDialog} onClose={handleCloseCompleteDialog} maxWidth="sm" fullWidth>
        <DialogTitle>Finalizar Agendamento</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <Typography variant="subtitle1" sx={{ mb: 2 }}>Informe o valor final de cada serviço:</Typography>
          {currentAppointment?.appointment_services.map(service => (
            <Box key={service.id} sx={{ mb: 2 }}>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                {service.services?.name || services.find(s => s.id === service.service_id)?.name || 'Serviço'}
              </Typography>
              <TextField
                fullWidth
                label="Valor Final"
                type="number"
                value={finalPrices[service.id] || ''}
                onChange={(e) => setFinalPrices({ ...finalPrices, [service.id]: e.target.value })}
                InputProps={{ startAdornment: <InputAdornment position="start">R$</InputAdornment> }}
                size="small"
                sx={{ borderRadius: 2 }}
              />
            </Box>
          ))}
          <Box sx={{ mt: 3, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
            <Typography variant="subtitle1">
              Valor Total: R$ {Object.values(finalPrices).reduce((sum, price) => sum + (Number(price) || 0), 0).toFixed(2)}
            </Typography>
          </Box>
        </DialogContent>
        <DialogActions sx={{ p: 2 }}>
          <Button onClick={handleCloseCompleteDialog} sx={{ color: 'text.secondary' }}>Cancelar</Button>
          <Button 
            onClick={handleSaveCompletedAppointment} 
            variant="contained" 
            color="success" 
            sx={{ borderRadius: 2 }}
          >
            Finalizar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Modal Excluir Agendamento */}
      <Dialog open={openDeleteDialog} onClose={handleCloseDeleteDialog}>
        <DialogTitle>Confirmar exclusão</DialogTitle>
        <DialogContent>
          <DialogContentText>Tem certeza que deseja excluir este agendamento?</DialogContentText>
          {currentAppointment && (
            <Box sx={{ mt: 2, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
              <Typography>Cliente: {clients.find(c => c.id === currentAppointment.client_id)?.name || 'Desconhecido'}</Typography>
              <Typography>Data: {new Date(currentAppointment.start_time).toLocaleString('pt-BR')}</Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDeleteDialog}>Cancelar</Button>
          <Button onClick={handleDeleteAppointment} color="error" variant="contained" disabled={loading}>
            {loading ? 'Excluindo...' : 'Excluir'}
          </Button>
        </DialogActions>
      </Dialog>

      <Snackbar open={!!error} autoHideDuration={6000} onClose={() => setError('')}>
        <Alert onClose={() => setError('')} severity="error">{error}</Alert>
      </Snackbar>
      <Snackbar open={!!success} autoHideDuration={6000} onClose={() => setSuccess('')}>
        <Alert onClose={() => setSuccess('')} severity="success">{success}</Alert>
      </Snackbar>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Clients.tsx
Código:
import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TextField,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  InputAdornment,
  CircularProgress,
  Snackbar,
  Alert
} from '@mui/material';
import { 
  Add as AddIcon,
  Search as SearchIcon,
  Edit as EditIcon,
  Phone as PhoneIcon
} from '@mui/icons-material';
import { supabase } from '../lib/supabase';
import { useAuth } from '../context/AuthContext';

interface Client {
  id: string;
  name: string;
  phone: string;
  created_at: string;
}

export default function Clients() {
  const [clients, setClients] = useState<Client[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [openDialog, setOpenDialog] = useState(false);
  const [editingClient, setEditingClient] = useState<Client | null>(null);
  const [name, setName] = useState('');
  const [phone, setPhone] = useState('');
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'success' as 'success' | 'error' });
  const { user } = useAuth();

  useEffect(() => {
    fetchClients();
  }, []);

  const fetchClients = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('clients')
        .select('*')
        .order('name', { ascending: true });
      
      if (error) throw error;
      setClients(data || []);
    } catch (error) {
      console.error('Erro ao buscar clientes:', error);
      showSnackbar('Erro ao carregar clientes', 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleOpenDialog = (client?: Client) => {
    if (client) {
      setEditingClient(client);
      setName(client.name);
      setPhone(client.phone || '');
    } else {
      setEditingClient(null);
      setName('');
      setPhone('');
    }
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
  };

  const handleSaveClient = async () => {
    if (!name) {
      showSnackbar('Nome é obrigatório', 'error');
      return;
    }

    try {
      if (editingClient) {
        // Atualizar cliente existente
        const { error } = await supabase
          .from('clients')
          .update({ name, phone })
          .eq('id', editingClient.id);
        
        if (error) throw error;
        showSnackbar('Cliente atualizado com sucesso', 'success');
      } else {
        // Criar novo cliente
        const { error } = await supabase
          .from('clients')
          .insert([{ name, phone, created_by: user?.id }]);
        
        if (error) throw error;
        showSnackbar('Cliente criado com sucesso', 'success');
      }
      
      handleCloseDialog();
      fetchClients();
    } catch (error) {
      console.error('Erro ao salvar cliente:', error);
      showSnackbar('Erro ao salvar cliente', 'error');
    }
  };

  const showSnackbar = (message: string, severity: 'success' | 'error') => {
    setSnackbar({ open: true, message, severity });
  };

  const handleCloseSnackbar = () => {
    setSnackbar({ ...snackbar, open: false });
  };

  const filteredClients = clients.filter(client => 
    client.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (client.phone && client.phone.includes(searchTerm))
  );

  // Phone mask function
  const handlePhoneChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let value = e.target.value.replace(/\D/g, ''); // Remove non-digits
    
    if (value.length <= 11) {
      // Format as (XX) X XXXX-XXXX
      if (value.length > 0) {
        value = value.replace(/^(\d{2})(\d)/g, '($1) $2');
      }
      if (value.length > 4) {
        value = value.replace(/(\) \d)(\d{4})(\d)/, '$1 $2-$3');
      }
      setPhone(value);
    }
  };

  const formatPhoneDisplay = (phone: string) => {
    if (!phone) return '';
    
    const digits = phone.replace(/\D/g, '');
    if (digits.length === 11) {
      return `(${digits.substring(0, 2)}) ${digits.substring(2, 3)} ${digits.substring(3, 7)}-${digits.substring(7)}`;
    } else if (digits.length === 10) {
      return `(${digits.substring(0, 2)}) ${digits.substring(2, 6)}-${digits.substring(6)}`;
    }
    return phone;
  };

  return (
    <Box>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" sx={{ fontWeight: 'medium' }}>
          Clientes
        </Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          onClick={() => handleOpenDialog()}
        >
          Novo Cliente
        </Button>
      </Box>
      
      <Paper sx={{ p: 2, mb: 3 }}>
        <TextField
          fullWidth
          variant="outlined"
          placeholder="Buscar por nome ou telefone..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <SearchIcon />
              </InputAdornment>
            ),
          }}
        />
      </Paper>
      
      <TableContainer component={Paper}>
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
            <CircularProgress />
          </Box>
        ) : (
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Nome</TableCell>
                <TableCell>Telefone</TableCell>
                <TableCell align="right">Ações</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {filteredClients.length > 0 ? (
                filteredClients.map((client) => (
                  <TableRow key={client.id}>
                    <TableCell>{client.name}</TableCell>
                    <TableCell>
                      {client.phone ? (
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                          <PhoneIcon fontSize="small" sx={{ mr: 1, color: 'text.secondary' }} />
                          {formatPhoneDisplay(client.phone)}
                        </Box>
                      ) : (
                        <Typography variant="body2" color="text.secondary">
                          Não informado
                        </Typography>
                      )}
                    </TableCell>
                    <TableCell align="right">
                      <IconButton 
                        color="primary" 
                        onClick={() => handleOpenDialog(client)}
                        size="small"
                      >
                        <EditIcon />
                      </IconButton>
                    </TableCell>
                  </TableRow>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={3} align="center">
                    {searchTerm ? 'Nenhum cliente encontrado' : 'Nenhum cliente cadastrado'}
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        )}
      </TableContainer>
      
      {/* Dialog para criar/editar cliente */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>
          {editingClient ? 'Editar Cliente' : 'Novo Cliente'}
        </DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Nome"
            type="text"
            fullWidth
            variant="outlined"
            value={name}
            onChange={(e) => setName(e.target.value)}
            required
            sx={{ mb: 2 }}
          />
          <TextField
            margin="dense"
            label="Telefone"
            type="tel"
            fullWidth
            variant="outlined"
            value={phone}
            onChange={handlePhoneChange}
            placeholder="(00) 0 0000-0000"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <PhoneIcon fontSize="small" color="action" />
                </InputAdornment>
              ),
            }}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancelar</Button>
          <Button onClick={handleSaveClient} variant="contained">
            Salvar
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Snackbar para feedback */}
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={6000} 
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert onClose={handleCloseSnackbar} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Dashboard.tsx
Código:
import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Grid, 
  CircularProgress, 
  Card, 
  CardContent,
  TextField,
  MenuItem,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow
} from '@mui/material';
import { 
  People, 
  Spa, 
  CalendarToday, 
  DateRange,
  ShoppingCart
} from '@mui/icons-material';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, PieChart, Pie, Cell } from 'recharts';
import { supabase } from '../lib/supabase';
import { useAuth } from '../context/AuthContext';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { 
  startOfMonth, 
  endOfMonth, 
  startOfWeek, 
  endOfWeek, 
  format, 
  isWithinInterval, 
  startOfDay, 
  endOfDay,
  parseISO,
  isSameDay
} from 'date-fns';

// Tipagem para os dados
interface Appointment {
  id: string;
  client_id: string;
  start_time: string;
  end_time: string;
  status: string;
  final_price: number;
  appointment_services: { service_id: string; final_price: number }[];
  created_by: string;
}

interface Sale {
  id: string;
  sale_date: string;
  total_amount: number;
  payment_method: string | null;
  notes: string | null;
  client_id?: string;
  client?: {
    name: string;
  };
  sale_items: {
    id: string;
    inventory_id: string;
    quantity: number;
    unit_price: number;
    total_price: number;
    inventory: {
      name: string;
    };
  }[];
}

interface Client {
  id: string;
  name: string;
}

interface Service {
  id: string;
  name: string;
}

interface InventoryItem {
  id: string;
  name: string;
  quantity: number;
  cost_price: number;
  selling_price: number;
}

interface Transaction {
  id: string;
  transaction_date: string;
  description: string;
  amount: number;
  type: string;
  category: string | null;
  related_sale_id: string | null;
  related_appointment_id: string | null;
  payment_method: string | null;
}

export default function Dashboard() {
  const [appointments, setAppointments] = useState<Appointment[]>([]);
  const [sales, setSales] = useState<Sale[]>([]);
  const [clients, setClients] = useState<Client[]>([]);
  const [services, setServices] = useState<Service[]>([]);
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [loading, setLoading] = useState(true);
  const [startDate, setStartDate] = useState<Date | null>(startOfMonth(new Date()));
  const [endDate, setEndDate] = useState<Date | null>(endOfMonth(new Date()));
  const [dateRange, setDateRange] = useState('month');
  const [openDetailsDialog, setOpenDetailsDialog] = useState(false);
  const [detailsTitle, setDetailsTitle] = useState('');
  const [detailsData, setDetailsData] = useState<any[]>([]);
  const [detailsType, setDetailsType] = useState<'services' | 'sales' | 'all' | null>(null);
  const { user } = useAuth();

  useEffect(() => {
    // Update date range when selection changes
    if (dateRange === 'day') {
      setStartDate(startOfDay(new Date()));
      setEndDate(endOfDay(new Date()));
    } else if (dateRange === 'week') {
      setStartDate(startOfWeek(new Date(), { weekStartsOn: 0 }));
      setEndDate(endOfWeek(new Date(), { weekStartsOn: 0 }));
    } else if (dateRange === 'month') {
      setStartDate(startOfMonth(new Date()));
      setEndDate(endOfMonth(new Date()));
    }
  }, [dateRange]);

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const [appointmentsData, clientsData, servicesData, inventoryData, salesData, transactionsData] = await Promise.all([
        supabase
          .from('appointments')
          .select('*, appointment_services(service_id, services(name), final_price)')
          .order('start_time', { ascending: false }),
        supabase.from('clients').select('*'),
        supabase.from('services').select('*'),
        supabase.from('inventory').select('*'),
        supabase
          .from('sales')
          .select(`
            *,
            client:client_id (name),
            sale_items(
              id,
              inventory_id,
              quantity,
              unit_price,
              total_price,
              inventory(name)
            )
          `)
          .order('sale_date', { ascending: false }),
        supabase.from('financial_transactions').select('*')
      ]);

      if (appointmentsData.error) throw appointmentsData.error;
      if (clientsData.error) throw clientsData.error;
      if (servicesData.error) throw servicesData.error;
      if (inventoryData.error) throw inventoryData.error;
      if (salesData.error) throw salesData.error;
      if (transactionsData.error) throw transactionsData.error;

      setAppointments(appointmentsData.data || []);
      setClients(clientsData.data || []);
      setServices(servicesData.data || []);
      setInventory(inventoryData.data || []);
      setSales(salesData.data || []);
      setTransactions(transactionsData.data || []);
    } catch (error) {
      console.error('Erro ao carregar dados:', error);
    } finally {
      setLoading(false);
    }
  };

  // Filter appointments by date range
  const filteredAppointments = appointments.filter(appointment => {
    if (!startDate || !endDate) return true;
    
    try {
      const appointmentDate = parseISO(appointment.start_time);
      return isWithinInterval(appointmentDate, { start: startDate, end: endDate });
    } catch (error) {
      console.error('Error filtering appointment:', error);
      return false;
    }
  });

  // Filter sales by date range
  const filteredSales = sales.filter(sale => {
    if (!startDate || !endDate) return true;
    
    try {
      const saleDate = parseISO(sale.sale_date);
      return isWithinInterval(saleDate, { start: startDate, end: endDate });
    } catch (error) {
      console.error('Error filtering sale:', error);
      return false;
    }
  });

  // Filter transactions by date range
  const filteredTransactions = transactions.filter(transaction => {
    if (!startDate || !endDate) return true;
    
    try {
      const transactionDate = parseISO(transaction.transaction_date);
      return isWithinInterval(transactionDate, { start: startDate, end: endDate });
    } catch (error) {
      console.error('Error filtering transaction:', error);
      return false;
    }
  });

  // Calculate revenue for different periods
  const calculateRevenue = (period: 'day' | 'week' | 'month' | 'custom') => {
    let start: Date;
    let end: Date;
    
    if (period === 'day') {
      start = startOfDay(new Date());
      end = endOfDay(new Date());
    } else if (period === 'week') {
      start = startOfWeek(new Date(), { weekStartsOn: 0 });
      end = endOfWeek(new Date(), { weekStartsOn: 0 });
    } else if (period === 'month') {
      start = startOfMonth(new Date());
      end = endOfMonth(new Date());
    } else {
      // Custom period uses the selected date range
      start = startDate || startOfMonth(new Date());
      end = endDate || endOfMonth(new Date());
    }
    
    // Services revenue
    const servicesRevenue = appointments
      .filter(appointment => {
        try {
          const appointmentDate = parseISO(appointment.start_time);
          return isWithinInterval(appointmentDate, { start, end }) && 
                appointment.status === 'completed';
        } catch (error) {
          console.error('Error calculating service revenue:', error);
          return false;
        }
      })
      .reduce((total, appointment) => total + (appointment.final_price || 0), 0);
    
    // Sales revenue
    const salesRevenue = sales
      .filter(sale => {
        try {
          const saleDate = parseISO(sale.sale_date);
          return isWithinInterval(saleDate, { start, end });
        } catch (error) {
          console.error('Error calculating sales revenue:', error);
          return false;
        }
      })
      .reduce((total, sale) => total + (sale.total_amount || 0), 0);
    
    return {
      total: servicesRevenue + salesRevenue,
      services: servicesRevenue,
      sales: salesRevenue
    };
  };

  // Calculate inventory value and profit potential
  const inventoryValue = inventory.reduce((total, item) => total + (item.cost_price * item.quantity), 0);
  const inventoryPotentialProfit = inventory.reduce((total, item) => 
    total + ((item.selling_price - item.cost_price) * item.quantity), 0);

  // Data for the monthly appointments chart
  const monthlyData = Array.from({ length: 12 }, (_, i) => {
    const month = i + 1;
    const monthAppointments = appointments.filter(appointment => {
      const date = new Date(appointment.start_time);
      return date.getMonth() + 1 === month;
    });
    
    const monthSales = sales.filter(sale => {
      const date = new Date(sale.sale_date);
      return date.getMonth() + 1 === month;
    });
    
    return {
      month: new Date(0, i).toLocaleString('pt-BR', { month: 'short' }),
      Agendamentos: monthAppointments.length,
      ReceitaServicos: monthAppointments
        .filter(a => a.status === 'completed')
        .reduce((sum, a) => sum + (a.final_price || 0), 0),
      ReceitaVendas: monthSales
        .reduce((sum, s) => sum + (s.total_amount || 0), 0)
    };
  });

  // Data for the services pie chart
  const serviceCounts: { [key: string]: number } = {};
  filteredAppointments.forEach(appointment => {
    appointment.appointment_services.forEach(as => {
      const serviceName = services.find(s => s.id === as.service_id)?.name || 'Desconhecido';
      serviceCounts[serviceName] = (serviceCounts[serviceName] || 0) + 1;
    });
  });

  const popularServices = Object.entries(serviceCounts)
    .map(([name, count]) => ({ name, value: count }))
    .sort((a, b) => b.value - a.value)
    .slice(0, 5);

  // Upcoming appointments
  const upcomingAppointments = appointments
    .filter(appointment => {
      try {
        return new Date(appointment.start_time) >= new Date() && appointment.status === 'scheduled';
      } catch (error) {
        console.error('Error filtering upcoming appointments:', error);
        return false;
      }
    })
    .sort((a, b) => new Date(a.start_time).getTime() - new Date(b.start_time).getTime())
    .slice(0, 5);

  // Colors for charts
  const COLORS = ['#f8bbd0', '#81d4fa', '#c8e6c9', '#ffe0b2', '#e1bee7'];

  // Today's appointments
  const todayAppointments = appointments.filter(appointment => {
    try {
      const appointmentDate = parseISO(appointment.start_time);
      return isSameDay(appointmentDate, new Date());
    } catch (error) {
      console.error('Error filtering today appointments:', error);
      return false;
    }
  });

  // Today's sales
  const todaySales = sales.filter(sale => {
    try {
      const saleDate = parseISO(sale.sale_date);
      return isSameDay(saleDate, new Date());
    } catch (error) {
      console.error('Error filtering today sales:', error);
      return false;
    }
  });

  // Handle revenue card click to show details
  const handleRevenueCardClick = (type: 'services' | 'sales' | 'all', period: 'day' | 'week' | 'month' | 'custom') => {
    let start: Date;
    let end: Date;
    let title = '';
    
    if (period === 'day') {
      start = startOfDay(new Date());
      end = endOfDay(new Date());
      title = type === 'all' 
        ? 'Receita Total do Dia' 
        : `Receita de ${type === 'services' ? 'Serviços' : 'Vendas'} do Dia`;
    } else if (period === 'week') {
      start = startOfWeek(new Date(), { weekStartsOn: 0 });
      end = endOfWeek(new Date(), { weekStartsOn: 0 });
      title = type === 'all' 
        ? 'Receita Total da Semana' 
        : `Receita de ${type === 'services' ? 'Serviços' : 'Vendas'} da Semana`;
    } else if (period === 'month') {
      start = startOfMonth(new Date());
      end = endOfMonth(new Date());
      title = type === 'all' 
        ? 'Receita Total do Mês' 
        : `Receita de ${type === 'services' ? 'Serviços' : 'Vendas'} do Mês`;
    } else {
      // Custom period uses the selected date range
      start = startDate || startOfMonth(new Date());
      end = endDate || endOfMonth(new Date());
      title = type === 'all' 
        ? 'Receita Total do Período' 
        : `Receita de ${type === 'services' ? 'Serviços' : 'Vendas'} do Período`;
    }
    
    let data: any[] = [];
    
    if (type === 'services' || type === 'all') {
      const servicesData = appointments
        .filter(appointment => {
          try {
            const appointmentDate = parseISO(appointment.start_time);
            return isWithinInterval(appointmentDate, { start, end }) && 
                 appointment.status === 'completed';
          } catch (error) {
            console.error('Error filtering services data:', error);
            return false;
          }
        })
        .map(appointment => {
          const client = clients.find(c => c.id === appointment.client_id);
          return {
            id: appointment.id,
            date: format(parseISO(appointment.start_time), 'dd/MM/yyyy HH:mm'),
            description: `Serviço: ${client?.name || 'Cliente não identificado'}`,
            client: client?.name || 'Desconhecido',
            services: appointment.appointment_services
              .map(as => services.find(s => s.id === as.service_id)?.name)
              .join(', '),
            amount: appointment.final_price,
            type: 'service'
          };
        });
        
      if (type === 'services') {
        data = servicesData;
      } else {
        data = [...data, ...servicesData];
      }
    }
    
    if (type === 'sales' || type === 'all') {
      const salesData = sales
        .filter(sale => {
          try {
            const saleDate = parseISO(sale.sale_date);
            return isWithinInterval(saleDate, { start, end });
          } catch (error) {
            console.error('Error filtering sales data:', error);
            return false;
          }
        })
        .map(sale => {
          return {
            id: sale.id,
            date: format(parseISO(sale.sale_date), 'dd/MM/yyyy HH:mm'),
            description: `Venda: ${sale.client?.name || 'Cliente não identificado'}`,
            client: sale.client?.name || 'Não informado',
            payment: sale.payment_method || 'Não informado',
            amount: sale.total_amount,
            type: 'sale'
          };
        });
        
      if (type === 'sales') {
        data = salesData;
      } else {
        data = [...data, ...salesData];
      }
    }
    
    // Sort by date (newest first)
    data.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
    
    setDetailsTitle(title);
    setDetailsData(data);
    setDetailsType(type);
    setOpenDetailsDialog(true);
  };

  const handleCloseDetailsDialog = () => {
    setOpenDetailsDialog(false);
    setDetailsData([]);
    setDetailsType(null);
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" sx={{ fontWeight: 'medium', mb: 4 }}>
        Dashboard
      </Typography>

      {/* Date filter */}
      <Paper sx={{ p: 2, mb: 4, display: 'flex', flexWrap: 'wrap', gap: 2, alignItems: 'center' }}>
        <TextField
          select
          label="Período"
          value={dateRange}
          onChange={(e) => setDateRange(e.target.value)}
          sx={{ minWidth: 150 }}
        >
          <MenuItem value="day">Hoje</MenuItem>
          <MenuItem value="week">Esta Semana</MenuItem>
          <MenuItem value="month">Este Mês</MenuItem>
          <MenuItem value="custom">Personalizado</MenuItem>
        </TextField>
        
        {dateRange === 'custom' && (
          <>
            <DatePicker 
              label="Data Inicial"
              value={startDate}
              onChange={(newValue) => setStartDate(newValue)}
              slotProps={{ textField: { size: 'small' } }}
            />
            <DatePicker 
              label="Data Final"
              value={endDate}
              onChange={(newValue) => setEndDate(newValue)}
              slotProps={{ textField: { size: 'small' } }}
            />
          </>
        )}
        
        <Button 
          variant="outlined" 
          onClick={fetchData}
          startIcon={<DateRange />}
        >
          Atualizar
        </Button>
      </Paper>

      {/* Revenue cards */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            sx={{ 
              height: '100%', 
              borderLeft: '4px solid #f8bbd0',
              cursor: 'pointer',
              '&:hover': { boxShadow: 3 }
            }}
            onClick={() => handleRevenueCardClick('all', 'day')}
          >
            <CardContent>
              <Typography variant="subtitle2" color="text.secondary">
                Receita do Dia
              </Typography>
              <Typography variant="h5" sx={{ mt: 1, fontWeight: 'bold' }}>
                R$ {calculateRevenue('day').total.toFixed(2)}
              </Typography>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Serviços: R$ {calculateRevenue('day').services.toFixed(2)}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Vendas: R$ {calculateRevenue('day').sales.toFixed(2)}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            sx={{ 
              height: '100%', 
              borderLeft: '4px solid #81d4fa',
              cursor: 'pointer',
              '&:hover': { boxShadow: 3 }
            }}
            onClick={() => handleRevenueCardClick('all', 'week')}
          >
            <CardContent>
              <Typography variant="subtitle2" color="text.secondary">
                Receita da Semana
              </Typography>
              <Typography variant="h5" sx={{ mt: 1, fontWeight: 'bold' }}>
                R$ {calculateRevenue('week').total.toFixed(2)}
              </Typography>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Serviços: R$ {calculateRevenue('week').services.toFixed(2)}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Vendas: R$ {calculateRevenue('week').sales.toFixed(2)}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            sx={{ 
              height: '100%', 
              borderLeft: '4px solid #c8e6c9',
              cursor: 'pointer',
              '&:hover': { boxShadow: 3 }
            }}
            onClick={() => handleRevenueCardClick('all', 'month')}
          >
            <CardContent>
              <Typography variant="subtitle2" color="text.secondary">
                Receita do Mês
              </Typography>
              <Typography variant="h5" sx={{ mt: 1, fontWeight: 'bold' }}>
                R$ {calculateRevenue('month').total.toFixed(2)}
              </Typography>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Serviços: R$ {calculateRevenue('month').services.toFixed(2)}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Vendas: R$ {calculateRevenue('month').sales.toFixed(2)}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card 
            sx={{ 
              height: '100%', 
              borderLeft: '4px solid #ffe0b2',
              cursor: 'pointer',
              '&:hover': { boxShadow: 3 }
            }}
            onClick={() => handleRevenueCardClick('all', 'custom')}
          >
            <CardContent>
              <Typography variant="subtitle2" color="text.secondary">
                Receita do Período
              </Typography>
              <Typography variant="h5" sx={{ mt: 1, fontWeight: 'bold' }}>
                R$ {calculateRevenue('custom').total.toFixed(2)}
              </Typography>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 1 }}>
                <Typography variant="body2" color="text.secondary">
                  Serviços: R$ {calculateRevenue('custom').services.toFixed(2)}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  Vendas: R$ {calculateRevenue('custom').sales.toFixed(2)}
                </Typography>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Stats cards */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
            <People sx={{ color: 'primary.main', fontSize: 40 }} />
            <Box>
              <Typography variant="h6">{clients.length}</Typography>
              <Typography variant="subtitle2" color="text.secondary">
                Clientes
              </Typography>
            </Box>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
            <Spa sx={{ color: '#90caf9', fontSize: 40 }} />
            <Box>
              <Typography variant="h6">{services.length}</Typography>
              <Typography variant="subtitle2" color="text.secondary">
                Serviços
              </Typography>
            </Box>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
            <CalendarToday sx={{ color: '#81d4fa', fontSize: 40 }} />
            <Box>
              <Typography variant="h6">{appointments.length}</Typography>
              <Typography variant="subtitle2" color="text.secondary">
                Agendamentos
              </Typography>
            </Box>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Paper sx={{ p: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
            <ShoppingCart sx={{ color: '#e1bee7', fontSize: 40 }} />
            <Box>
              <Typography variant="h6">{sales.length}</Typography>
              <Typography variant="subtitle2" color="text.secondary">
                Vendas
              </Typography>
            </Box>
          </Paper>
        </Grid>
      </Grid>

      {/* Charts */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} md={8}>
          <Paper sx={{ p: 2, height: 350 }}>
            <Typography variant="h6" sx={{ mb: 2 }}>
              Receitas por Mês
            </Typography>
            <Box sx={{ height: 290, width: '100%', overflowX: 'auto' }}>
              <BarChart
                width={700}
                height={290}
                data={monthlyData}
                margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="month" />
                <YAxis yAxisId="left" />
                <YAxis yAxisId="right" orientation="right" />
                <Tooltip />
                <Legend />
                <Bar yAxisId="left" dataKey="ReceitaServicos" name="Serviços" fill="#f8bbd0" />
                <Bar yAxisId="left" dataKey="ReceitaVendas" name="Vendas" fill="#81d4fa" />
                <Bar yAxisId="right" dataKey="Agendamentos" name="Qtd. Agendamentos" fill="#c8e6c9" />
              </BarChart>
            </Box>
          </Paper>
        </Grid>
        <Grid item xs={12} md={4}>
          <Paper sx={{ p: 2, height: 350 }}>
            <Typography variant="h6" sx={{ mb: 2 }}>
              Serviços Mais Populares
            </Typography>
            <Box sx={{ height: 290, display: 'flex', justifyContent: 'center', alignItems: 'center' }}>
              {popularServices.length > 0 ? (
                <PieChart width={300} height={290}>
                  <Pie
                    data={popularServices}
                    dataKey="value"
                    nameKey="name"
                    cx="50%"
                    cy="50%"
                    innerRadius={60}
                    outerRadius={80}
                    fill="#8884d8"
                    label
                  >
                    {popularServices.map((_, index) => (
                      <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              ) : (
                <Typography color="text.secondary">
                  Nenhum serviço encontrado no período selecionado
                </Typography>
              )}
            </Box>
          </Paper>
        </Grid>
      </Grid>

      {/* Inventory and Upcoming appointments */}
      <Grid container spacing={2}>
        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6" sx={{ mb: 2 }}>
              Resumo do Estoque
            </Typography>
            <Grid container spacing={2}>
              <Grid item xs={6}>
                <Card sx={{ bgcolor: '#f5f5f5' }}>
                  <CardContent>
                    <Typography variant="subtitle2" color="text.secondary">
                      Valor Total
                    </Typography>
                    <Typography variant="h6">
                      R$ {inventoryValue.toFixed(2)}
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={6}>
                <Card sx={{ bgcolor: '#f5f5f5' }}>
                  <CardContent>
                    <Typography variant="subtitle2" color="text.secondary">
                      Lucro Potencial
                    </Typography>
                    <Typography variant="h6">
                      R$ {inventoryPotentialProfit.toFixed(2)}
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle1" sx={{ mb: 1 }}>
                Produtos com Estoque Baixo
              </Typography>
              {inventory.filter(item => item.quantity < 5).length > 0 ? (
                inventory
                  .filter(item => item.quantity < 5)
                  .slice(0, 5)
                  .map(item => (
                    <Box key={item.id} sx={{ mb: 1, display: 'flex', justifyContent: 'space-between' }}>
                      <Typography>{item.name}</Typography>
                      <Typography color={item.quantity <= 0 ? 'error' : 'warning.main'}>
                        {item.quantity} unidades
                      </Typography>
                    </Box>
                  ))
              ) : (
                <Typography color="text.secondary">
                  Nenhum produto com estoque baixo
                </Typography>
              )}
            </Box>
          </Paper>
        </Grid>
        <Grid item xs={12} md={6}>
          <Paper sx={{ p: 2 }}>
            <Typography variant="h6" sx={{ mb: 2 }}>
              Próximos Agendamentos
            </Typography>
            {upcomingAppointments.length === 0 ? (
              <Typography color="text.secondary">
                Nenhum agendamento futuro encontrado.
              </Typography>
            ) : (
              upcomingAppointments.map(appointment => {
                const client = clients.find(c => c.id === appointment.client_id);
                const serviceNames = appointment.appointment_services
                  .map(as => services.find(s => s.id === as.service_id)?.name)
                  .join(', ');
                return (
                  <Box key={appointment.id} sx={{ mb: 2, p: 1, borderLeft: '3px solid #f8bbd0', bgcolor: '#f5f5f5' }}>
                    <Typography variant="subtitle1">
                      {client?.name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {format(parseISO(appointment.start_time), 'dd/MM/yyyy HH:mm')}
                    </Typography>
                    <Typography variant="body2">
                      Serviço: {serviceNames}
                    </Typography>
                  </Box>
                );
              })
            )}
          </Paper>
        </Grid>
      </Grid>

      {/* Details Dialog */}
      <Dialog
        open={openDetailsDialog}
        onClose={handleCloseDetailsDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>{detailsTitle}</DialogTitle>
        <DialogContent>
          <TableContainer>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Data</TableCell>
                  <TableCell>Cliente</TableCell>
                  <TableCell>Descrição</TableCell>
                  <TableCell align="right">Valor</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {detailsData.length > 0 ? (
                  detailsData.map((item) => (
                    <TableRow key={item.id}>
                      <TableCell>{item.date}</TableCell>
                      <TableCell>{item.client}</TableCell>
                      <TableCell>{item.type === 'service' ? item.services : 'Venda de produtos'}</TableCell>
                      <TableCell align="right">R$ {item.amount.toFixed(2)}</TableCell>
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={4} align="center">
                      Nenhum dado encontrado
                    </TableCell>
                  </TableRow>
                )}
                {detailsData.length > 0 && (
                  <TableRow>
                    <TableCell colSpan={3} align="right" sx={{ fontWeight: 'bold' }}>
                      Total:
                    </TableCell>
                    <TableCell align="right" sx={{ fontWeight: 'bold' }}>
                      R$ {detailsData.reduce((sum, item) => sum + item.amount, 0).toFixed(2)}
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </TableContainer>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDetailsDialog}>Fechar</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Financial.tsx
Código:
import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  TextField, 
  Dialog, 
  DialogActions, 
  DialogContent, 
  DialogTitle, 
  IconButton, 
  InputAdornment, 
  CircularProgress, 
  Snackbar, 
  Alert,
  Grid,
  Chip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  SelectChangeEvent,
  Tabs,
  Tab,
  Card,
  CardContent,
  Tooltip,
  DialogContentText,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction
} from '@mui/material';
import { 
  Add as AddIcon, 
  Search as SearchIcon, 
  ArrowUpward as IncomeIcon,
  ArrowDownward as ExpenseIcon,
  FilterList as FilterIcon,
  PieChart as ChartIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
  AddCircleOutline as AddCategoryIcon
} from '@mui/icons-material';
import { supabase } from '../lib/supabase';
import { useAuth } from '../context/AuthContext';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { format, startOfMonth, endOfMonth, parseISO } from 'date-fns';
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip as RechartsTooltip } from 'recharts';

interface Transaction {
  id: string;
  transaction_date: string;
  description: string;
  amount: number;
  type: string;
  category: string;
  payment_method: string;
  notes: string;
  related_sale_id: string | null;
  related_appointment_id: string | null;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`financial-tabpanel-${index}`}
      aria-labelledby={`financial-tab-${index}`}
      {...other}
    >
      {value === index && (
        <Box sx={{ p: 3 }}>
          {children}
        </Box>
      )}
    </div>
  );
}

export default function Financial() {
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [filteredTransactions, setFilteredTransactions] = useState<Transaction[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [startDate, setStartDate] = useState<Date>(startOfMonth(new Date()));
  const [endDate, setEndDate] = useState<Date>(endOfMonth(new Date()));
  const [typeFilter, setTypeFilter] = useState('');
  const [categoryFilter, setCategoryFilter] = useState('');
  
  const [openNewTransactionDialog, setOpenNewTransactionDialog] = useState(false);
  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
  const [openDeleteLinkedDialog, setOpenDeleteLinkedDialog] = useState(false);
  const [openCategoryDialog, setOpenCategoryDialog] = useState(false);
  const [currentTransaction, setCurrentTransaction] = useState<Transaction | null>(null);
  const [transactionType, setTransactionType] = useState('expense');
  const [transactionAmount, setTransactionAmount] = useState('');
  const [transactionDescription, setTransactionDescription] = useState('');
  const [transactionCategory, setTransactionCategory] = useState('');
  const [transactionPaymentMethod, setTransactionPaymentMethod] = useState('');
  const [transactionNotes, setTransactionNotes] = useState('');
  const [transactionDate, setTransactionDate] = useState<Date | null>(new Date());
  
  // Category management
  const [incomeCategories, setIncomeCategories] = useState<string[]>([]);
  const [expenseCategories, setExpenseCategories] = useState<string[]>([]);
  const [newCategoryName, setNewCategoryName] = useState('');
  const [editCategoryName, setEditCategoryName] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('');
  const [categoryType, setCategoryType] = useState<'income' | 'expense'>('expense');
  const [categoryAction, setCategoryAction] = useState<'add' | 'edit' | 'delete'>('add');
  
  const [tabValue, setTabValue] = useState(0);
  const [categories, setCategories] = useState<string[]>([]);
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { user } = useAuth();

  // Colors for charts
  const COLORS = ['#f8bbd0', '#81d4fa', '#c8e6c9', '#ffe0b2', '#e1bee7', '#b39ddb', '#90caf9', '#ffcc80'];

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('financial_transactions')
        .select('*')
        .order('transaction_date', { ascending: false });

      if (error) throw error;

      setTransactions(data || []);
      
      // Extract unique categories
      const uniqueCategories = Array.from(
        new Set(data?.map(item => item.category).filter(Boolean) || [])
      );
      setCategories(uniqueCategories);
      
      // Separate income and expense categories
      const incomeCategs = Array.from(
        new Set(data?.filter(item => item.type === 'income').map(item => item.category).filter(Boolean) || [])
      );
      
      const expenseCategs = Array.from(
        new Set(data?.filter(item => item.type === 'expense').map(item => item.category).filter(Boolean) || [])
      );
      
      // Add default categories if they don't exist
      const defaultIncomeCategories = ['Serviços', 'Vendas', 'Outros'];
      const defaultExpenseCategories = ['Aluguel', 'Salários', 'Produtos', 'Equipamentos', 'Marketing', 'Impostos', 'Utilidades', 'Outros'];
      
      setIncomeCategories([...new Set([...incomeCategs, ...defaultIncomeCategories])]);
      setExpenseCategories([...new Set([...expenseCategs, ...defaultExpenseCategories])]);
      
      handleFilter(data || []);
    } catch (error) {
      setError('Erro ao carregar dados');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  const handleFilter = (data = transactions) => {
    let filtered = data;
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(transaction =>
        transaction.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        (transaction.category && transaction.category.toLowerCase().includes(searchTerm.toLowerCase())) ||
        (transaction.payment_method && transaction.payment_method.toLowerCase().includes(searchTerm.toLowerCase())) ||
        (transaction.notes && transaction.notes.toLowerCase().includes(searchTerm.toLowerCase()))
      );
    }
    
    // Filter by date range
    if (startDate && endDate) {
      filtered = filtered.filter(transaction => {
        try {
          const transactionDate = parseISO(transaction.transaction_date);
          return transactionDate >= startDate && transactionDate <= endDate;
        } catch (error) {
          console.error('Error filtering by date:', error);
          return false;
        }
      });
    }
    
    // Filter by type
    if (typeFilter) {
      filtered = filtered.filter(transaction => transaction.type === typeFilter);
    }
    
    // Filter by category
    if (categoryFilter) {
      filtered = filtered.filter(transaction => transaction.category === categoryFilter);
    }
    
    setFilteredTransactions(filtered);
  };

  useEffect(() => {
    handleFilter();
  }, [searchTerm, startDate, endDate, typeFilter, categoryFilter, transactions]);

  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
  };

  const handleOpenNewTransactionDialog = (transaction?: Transaction) => {
    if (transaction) {
      // Edit mode
      setCurrentTransaction(transaction);
      setTransactionType(transaction.type);
      setTransactionAmount(transaction.amount.toString());
      setTransactionDescription(transaction.description);
      setTransactionCategory(transaction.category || '');
      setTransactionPaymentMethod(transaction.payment_method || '');
      setTransactionNotes(transaction.notes || '');
      setTransactionDate(new Date(transaction.transaction_date));
    } else {
      // New transaction mode
      setCurrentTransaction(null);
      setTransactionType('expense');
      setTransactionAmount('');
      setTransactionDescription('');
      setTransactionCategory('');
      setTransactionPaymentMethod('');
      setTransactionNotes('');
      setTransactionDate(new Date());
    }
    setOpenNewTransactionDialog(true);
  };

  const handleCloseNewTransactionDialog = () => {
    setOpenNewTransactionDialog(false);
  };

  const handleOpenDeleteDialog = (transaction: Transaction) => {
    setCurrentTransaction(transaction);
    
    if (transaction.related_sale_id || transaction.related_appointment_id) {
      setOpenDeleteLinkedDialog(true);
    } else {
      setOpenDeleteDialog(true);
    }
  };

  const handleCloseDeleteDialog = () => {
    setOpenDeleteDialog(false);
  };
  
  const handleCloseDeleteLinkedDialog = () => {
    setOpenDeleteLinkedDialog(false);
  };

  const handleTransactionTypeChange = (event: SelectChangeEvent) => {
    setTransactionType(event.target.value);
    // Reset category when changing type
    setTransactionCategory('');
  };

  const handleTransactionCategoryChange = (event: SelectChangeEvent) => {
    setTransactionCategory(event.target.value);
  };

  const handleTransactionPaymentMethodChange = (event: SelectChangeEvent) => {
    setTransactionPaymentMethod(event.target.value);
  };

  // Category management
  const handleOpenCategoryDialog = (action: 'add' | 'edit' | 'delete', type: 'income' | 'expense', category?: string) => {
    setCategoryAction(action);
    setCategoryType(type);
    setNewCategoryName('');
    setEditCategoryName('');
    setSelectedCategory('');
    
    if (action === 'edit' || action === 'delete') {
      setSelectedCategory(category || '');
      setEditCategoryName(category || '');
    }
    
    setOpenCategoryDialog(true);
  };
  
  const handleCloseCategoryDialog = () => {
    setOpenCategoryDialog(false);
  };
  
  const handleAddCategory = () => {
    if (!newCategoryName.trim()) {
      setError('Nome da categoria é obrigatório');
      return;
    }
    
    if (categoryType === 'income') {
      if (incomeCategories.includes(newCategoryName)) {
        setError('Esta categoria já existe');
        return;
      }
      setIncomeCategories([...incomeCategories, newCategoryName]);
    } else {
      if (expenseCategories.includes(newCategoryName)) {
        setError('Esta categoria já existe');
        return;
      }
      setExpenseCategories([...expenseCategories, newCategoryName]);
    }
    
    setSuccess('Categoria adicionada com sucesso!');
    handleCloseCategoryDialog();
  };
  
  const handleEditCategory = () => {
    if (!editCategoryName.trim() || !selectedCategory) {
      setError('Nome da categoria é obrigatório');
      return;
    }
    
    if (categoryType === 'income') {
      if (incomeCategories.includes(editCategoryName) && editCategoryName !== selectedCategory) {
        setError('Esta categoria já existe');
        return;
      }
      
      const updatedCategories = incomeCategories.map(cat => 
        cat === selectedCategory ? editCategoryName : cat
      );
      setIncomeCategories(updatedCategories);
      
      // Update transactions with this category
      updateTransactionCategories(selectedCategory, editCategoryName);
    } else {
      if (expenseCategories.includes(editCategoryName) && editCategoryName !== selectedCategory) {
        setError('Esta categoria já existe');
        return;
      }
      
      const updatedCategories = expenseCategories.map(cat => 
        cat === selectedCategory ? editCategoryName : cat
      );
      setExpenseCategories(updatedCategories);
      
      // Update transactions with this category
      updateTransactionCategories(selectedCategory, editCategoryName);
    }
    
    setSuccess('Categoria atualizada com sucesso!');
    handleCloseCategoryDialog();
  };
  
  const handleDeleteCategory = () => {
    if (!selectedCategory) {
      setError('Selecione uma categoria para excluir');
      return;
    }
    
    // Check if category is in use
    const categoryInUse = transactions.some(t => 
      t.category === selectedCategory && t.type === categoryType
    );
    
    if (categoryInUse) {
      setError('Esta categoria está em uso e não pode ser excluída');
      return;
    }
    
    if (categoryType === 'income') {
      setIncomeCategories(incomeCategories.filter(cat => cat !== selectedCategory));
    } else {
      setExpenseCategories(expenseCategories.filter(cat => cat !== selectedCategory));
    }
    
    setSuccess('Categoria excluída com sucesso!');
    handleCloseCategoryDialog();
  };
  
  const updateTransactionCategories = async (oldCategory: string, newCategory: string) => {
    try {
      // Update all transactions with this category
      const { error } = await supabase
        .from('financial_transactions')
        .update({ category: newCategory })
        .eq('category', oldCategory)
        .eq('type', categoryType);
      
      if (error) throw error;
      
      // Refresh data
      fetchData();
    } catch (error) {
      console.error('Error updating transaction categories:', error);
      setError('Erro ao atualizar transações com esta categoria');
    }
  };

  const handleSaveTransaction = async () => {
    if (!transactionDescription || !transactionAmount || !transactionType || !transactionDate) {
      setError('Preencha os campos obrigatórios');
      return;
    }

    if (isNaN(Number(transactionAmount)) || Number(transactionAmount) <= 0) {
      setError('Valor inválido');
      return;
    }

    try {
      if (currentTransaction) {
        // Update existing transaction
        const { error } = await supabase
          .from('financial_transactions')
          .update({
            transaction_date: transactionDate.toISOString(),
            description: transactionDescription,
            amount: Number(transactionAmount),
            type: transactionType,
            category: transactionCategory || null,
            payment_method: transactionPaymentMethod || null,
            notes: transactionNotes || null
          })
          .eq('id', currentTransaction.id);

        if (error) throw error;
        setSuccess('Transação atualizada com sucesso!');
      } else {
        // Create new transaction
        const { error } = await supabase
          .from('financial_transactions')
          .insert([{
            transaction_date: transactionDate.toISOString(),
            description: transactionDescription,
            amount: Number(transactionAmount),
            type: transactionType,
            category: transactionCategory || null,
            payment_method: transactionPaymentMethod || null,
            notes: transactionNotes || null,
            created_by: user?.id
          }]);

        if (error) throw error;
        setSuccess('Transação criada com sucesso!');
      }
      
      handleCloseNewTransactionDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao salvar transação');
      console.error(error);
    }
  };

  const handleDeleteTransaction = async () => {
    if (!currentTransaction) return;

    try {
      // Check if this transaction is related to a sale or appointment
      if (currentTransaction.related_sale_id || currentTransaction.related_appointment_id) {
        setError('Esta transação está vinculada a uma venda ou agendamento e não pode ser excluída diretamente.');
        handleCloseDeleteDialog();
        return;
      }

      const { error } = await supabase
        .from('financial_transactions')
        .delete()
        .eq('id', currentTransaction.id);

      if (error) throw error;
      
      setSuccess('Transação excluída com sucesso!');
      handleCloseDeleteDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao excluir transação');
      console.error(error);
    }
  };
  
  const handleDeleteLinkedTransaction = async () => {
    if (!currentTransaction) return;
    
    try {
      setLoading(true);
      
      if (currentTransaction.related_appointment_id) {
        // Delete appointment and its related transaction
        
        // 1. Delete appointment services
        const { error: servicesError } = await supabase
          .from('appointment_services')
          .delete()
          .eq('appointment_id', currentTransaction.related_appointment_id);
          
        if (servicesError) throw servicesError;
        
        // 2. Delete the appointment
        const { error: appointmentError } = await supabase
          .from('appointments')
          .delete()
          .eq('id', currentTransaction.related_appointment_id);
          
        if (appointmentError) throw appointmentError;
        
        // 3. Delete the financial transaction
        const { error: transactionError } = await supabase
          .from('financial_transactions')
          .delete()
          .eq('id', currentTransaction.id);
          
        if (transactionError) throw transactionError;
        
        setSuccess('Agendamento e transação financeira excluídos com sucesso!');
      } 
      else if (currentTransaction.related_sale_id) {
        // Delete sale and its related transaction
        
        // 1. Delete sale items
        const { error: itemsError } = await supabase
          .from('sale_items')
          .delete()
          .eq('sale_id', currentTransaction.related_sale_id);
          
        if (itemsError) throw itemsError;
        
        // 2. Delete the sale
        const { error: saleError } = await supabase
          .from('sales')
          .delete()
          .eq('id', currentTransaction.related_sale_id);
          
        if (saleError) throw saleError;
        
        // 3. Delete the financial transaction
        const { error: transactionError } = await supabase
          .from('financial_transactions')
          .delete()
          .eq('id', currentTransaction.id);
          
        if (transactionError) throw transactionError;
        
        setSuccess('Venda e transação financeira excluídas com sucesso!');
      }
      
      handleCloseDeleteLinkedDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao excluir registros vinculados');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  // Calculate financial summary
  const calculateSummary = () => {
    const income = filteredTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + t.amount, 0);
      
    const expense = filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + t.amount, 0);
      
    return {
      income,
      expense,
      balance: income - expense
    };
  };

  // Prepare data for charts
  const prepareChartData = () => {
    // Income by category
    const incomeByCategory = filteredTransactions
      .filter(t => t.type === 'income')
      .reduce((acc, t) => {
        const category = t.category || 'Sem categoria';
        acc[category] = (acc[category] || 0) + t.amount;
        return acc;
      }, {} as Record<string, number>);
      
    // Expense by category
    const expenseByCategory = filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((acc, t) => {
        const category = t.category || 'Sem categoria';
        acc[category] = (acc[category] || 0) + t.amount;
        return acc;
      }, {} as Record<string, number>);
      
    return {
      income: Object.entries(incomeByCategory).map(([name, value]) => ({ name, value })),
      expense: Object.entries(expenseByCategory).map(([name, value]) => ({ name, value }))
    };
  };

  const summary = calculateSummary();
  const chartData = prepareChartData();

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      {/* Cabeçalho */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" sx={{ fontWeight: 'medium' }}>
          Financeiro
        </Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          onClick={() => handleOpenNewTransactionDialog()}
        >
          Nova Transação
        </Button>
      </Box>

      {/* Resumo financeiro */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%', borderLeft: '4px solid #c8e6c9' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Receitas
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'success.main' }}>
              R$ {summary.income.toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%', borderLeft: '4px solid #ffcdd2' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Despesas
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold', color: 'error.main' }}>
              R$ {summary.expense.toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%', borderLeft: '4px solid #bbdefb' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Saldo
            </Typography>
            <Typography 
              variant="h5" 
              sx={{ 
                fontWeight: 'bold', 
                color: summary.balance >= 0 ? 'success.main' : 'error.main' 
              }}
            >
              R$ {summary.balance.toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
      </Grid>

      {/* Filtros */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} md={3}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Buscar transações..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />
          </Grid>
          <Grid item xs={12} md={2}>
            <DatePicker
              label="Data Inicial"
              value={startDate}
              onChange={(newValue) => setStartDate(newValue || startOfMonth(new Date()))}
              slotProps={{ textField: { fullWidth: true } }}
            />
          </Grid>
          <Grid item xs={12} md={2}>
            <DatePicker
              label="Data Final"
              value={endDate}
              onChange={(newValue) => setEndDate(newValue || endOfMonth(new Date()))}
              slotProps={{ textField: { fullWidth: true } }}
            />
          </Grid>
          <Grid item xs={12} md={2}>
            <FormControl fullWidth>
              <InputLabel id="type-filter-label">Tipo</InputLabel>
              <Select
                labelId="type-filter-label"
                value={typeFilter}
                label="Tipo"
                onChange={(e) => setTypeFilter(e.target.value)}
              >
                <MenuItem value="">Todos</MenuItem>
                <MenuItem value="income">Receitas</MenuItem>
                <MenuItem value="expense">Despesas</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          <Grid item xs={12} md={2}>
            <FormControl fullWidth>
              <InputLabel id="category-filter-label">Categoria</InputLabel>
              <Select
                labelId="category-filter-label"
                value={categoryFilter}
                label="Categoria"
                onChange={(e) => setCategoryFilter(e.target.value)}
              >
                <MenuItem value="">Todas</MenuItem>
                {categories.map(category => (
                  <MenuItem key={category} value={category}>{category}</MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
          <Grid item xs={12} md={1}>
            <Button 
              fullWidth 
              variant="outlined" 
              onClick={() => {
                setStartDate(startOfMonth(new Date()));
                setEndDate(endOfMonth(new Date()));
                setTypeFilter('');
                setCategoryFilter('');
                setSearchTerm('');
              }}
            >
              Limpar
            </Button>
          </Grid>
        </Grid>
      </Paper>

      {/* Tabs */}
      <Box sx={{ width: '100%' }}>
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs value={tabValue} onChange={handleTabChange} aria-label="financial tabs">
            <Tab label="Transações" />
            <Tab label="Relatórios" />
            <Tab label="Categorias" />
          </Tabs>
        </Box>
        
        {/* Transactions Tab */}
        <TabPanel value={tabValue} index={0}>
          <TableContainer component={Paper}>
            <Table>
              <TableHead>
                <TableRow>
                  <TableCell>Data</TableCell>
                  <TableCell>Descrição</TableCell>
                  <TableCell>Categoria</TableCell>
                  <TableCell>Forma de Pagamento</TableCell>
                  <TableCell align="right">Valor</TableCell>
                  <TableCell align="right">Ações</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {filteredTransactions.length > 0 ? (
                  filteredTransactions.map((transaction) => (
                    <TableRow key={transaction.id}>
                      <TableCell>{format(new Date(transaction.transaction_date), 'dd/MM/yyyy')}</TableCell>
                      <TableCell>{transaction.description}</TableCell>
                      <TableCell>
                        {transaction.category && (
                          <Chip 
                            label={transaction.category} 
                            size="small" 
                            sx={{ 
                              backgroundColor: transaction.type === 'income' ? 'rgba(200, 230, 201, 0.3)' : 'rgba(255, 205, 210, 0.3)',
                              borderRadius: '16px'
                            }} 
                          />
                        )}
                      </TableCell>
                      <TableCell>{transaction.payment_method}</TableCell>
                      <TableCell align="right">
                        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end' }}>
                          {transaction.type === 'income' ? (
                            <IncomeIcon fontSize="small" color="success" sx={{ mr: 0.5 }} />
                          ) : (
                            <ExpenseIcon fontSize="small" color="error" sx={{ mr: 0.5 }} />
                          )}
                          R$ {transaction.amount.toFixed(2)}
                        </Box>
                      </TableCell>
                      <TableCell align="right">
                        <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                          {transaction.related_sale_id || transaction.related_appointment_id ? (
                            <Tooltip title="Transações vinculadas não podem ser editadas diretamente">
                              <span>
                                <IconButton 
                                  color="primary" 
                                  disabled={true}
                                  size="small"
                                  sx={{ mr: 1 }}
                                >
                                  <EditIcon fontSize="small" />
                                </IconButton>
                              </span>
                            </Tooltip>
                          ) : (
                            <IconButton 
                              color="primary" 
                              onClick={() => handleOpenNewTransactionDialog(transaction)}
                              size="small"
                              sx={{ mr: 1 }}
                            >
                              <EditIcon fontSize="small" />
                            </IconButton>
                          )}
                          
                          <IconButton 
                            color="error" 
                            onClick={() => handleOpenDeleteDialog(transaction)}
                            size="small"
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </Box>
                      </TableCell>
                    </TableRow>
                  ))
                ) : (
                  <TableRow>
                    <TableCell colSpan={6} align="center">
                      Nenhuma transação encontrada
                    </TableCell>
                  </TableRow>
                )}
              </TableBody>
            </Table>
          </TableContainer>
        </TabPanel>
        
        {/* Reports Tab */}
        <TabPanel value={tabValue} index={1}>
          <Grid container spacing={3}>
            {/* Income Chart */}
            <Grid item xs={12} md={6}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                    <IncomeIcon color="success" sx={{ mr: 1 }} /> Receitas por Categoria
                  </Typography>
                  <Box sx={{ height: 300 }}>
                    {chartData.income.length > 0 ? (
                      <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                          <Pie
                            data={chartData.income}
                            cx="50%"
                            cy="50%"
                            labelLine={false}
                            outerRadius={80}
                            fill="#8884d8"
                            dataKey="value"
                            label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                          >
                            {chartData.income.map((_entry, index) => (
                              <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                            ))}
                          </Pie>
                          <RechartsTooltip formatter={(value) => `R$ ${Number(value).toFixed(2)}`} />
                          <Legend />
                        </PieChart>
                      </ResponsiveContainer>
                    ) : (
                      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                        <Typography color="text.secondary">Sem dados para exibir</Typography>
                      </Box>
                    )}
                  </Box>
                </CardContent>
              </Card>
            </Grid>
            
            {/* Expense Chart */}
            <Grid item xs={12} md={6}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                    <ExpenseIcon color="error" sx={{ mr: 1 }} /> Despesas por Categoria
                  </Typography>
                  <Box sx={{ height: 300 }}>
                    {chartData.expense.length > 0 ? (
                      <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                          <Pie
                            data={chartData.expense}
                            cx="50%"
                            cy="50%"
                            labelLine={false}
                            outerRadius={80}
                            fill="#8884d8"
                            dataKey="value"
                            label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                          >
                            {chartData.expense.map((_entry, index) => (
                              <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                            ))}
                          </Pie>
                          <RechartsTooltip formatter={(value) => `R$ ${Number(value).toFixed(2)}`} />
                          <Legend />
                        </PieChart>
                      </ResponsiveContainer>
                    ) : (
                      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100%' }}>
                        <Typography color="text.secondary">Sem dados para exibir</Typography>
                      </Box>
                    )}
                  </Box>
                </CardContent>
              </Card>
            </Grid>
            
            {/* Summary Cards */}
            <Grid item xs={12}>
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    Resumo por Categoria
                  </Typography>
                  <TableContainer>
                    <Table size="small">
                      <TableHead>
                        <TableRow>
                          <TableCell>Categoria</TableCell>
                          <TableCell align="right">Receitas</TableCell>
                          <TableCell align="right">Despesas</TableCell>
                          <TableCell align="right">Saldo</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {Array.from(new Set([
                          ...chartData.income.map(i => i.name),
                          ...chartData.expense.map(e => e.name)
                        ])).map(category => {
                          const incomeItem = chartData.income.find(i => i.name === category);
                          const expenseItem = chartData.expense.find(e => e.name === category);
                          const incomeValue = incomeItem ? incomeItem.value : 0;
                          const expenseValue = expenseItem ? expenseItem.value : 0;
                          const balance = incomeValue - expenseValue;
                          
                          return (
                            <TableRow key={category}>
                              <TableCell>{category}</TableCell>
                              <TableCell align="right" sx={{ color: 'success.main' }}>
                                {incomeValue > 0 ? `R$ ${incomeValue.toFixed(2)}` : '-'}
                              </TableCell>
                              <TableCell align="right" sx={{ color: 'error.main' }}>
                                {expenseValue > 0 ? `R$ ${expenseValue.toFixed(2)}` : '-'}
                              </TableCell>
                              <TableCell 
                                align="right" 
                                sx={{ 
                                  fontWeight: 'bold',
                                  color: balance >= 0 ? 'success.main' : 'error.main'
                                }}
                              >
                                R$ {balance.toFixed(2)}
                              </TableCell>
                            </TableRow>
                          );
                        })}
                      </TableBody>
                    </Table>
                  </TableContainer>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </TabPanel>
        
        {/* Categories Tab */}
        <TabPanel value={tabValue} index={2}>
          <Grid container spacing={3}>
            {/* Income Categories */}
            <Grid item xs={12} md={6}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center' }}>
                      <IncomeIcon color="success" sx={{ mr: 1 }} /> Categorias de Receita
                    </Typography>
                    <Button 
                      variant="outlined" 
                      color="success" 
                      startIcon={<AddCategoryIcon />}
                      size="small"
                      onClick={() => handleOpenCategoryDialog('add', 'income')}
                    >
                      Nova Categoria
                    </Button>
                  </Box>
                  
                  <List>
                    {incomeCategories.map(category => (
                      <ListItem key={category} divider>
                        <ListItemText primary={category} />
                        <ListItemSecondaryAction>
                          <IconButton 
                            edge="end" 
                            size="small" 
                            color="primary"
                            onClick={() => handleOpenCategoryDialog('edit', 'income', category)}
                            sx={{ mr: 1 }}
                          >
                            <EditIcon fontSize="small" />
                          </IconButton>
                          <IconButton 
                            edge="end" 
                            size="small" 
                            color="error"
                            onClick={() => handleOpenCategoryDialog('delete', 'income', category)}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
            
            {/* Expense Categories */}
            <Grid item xs={12} md={6}>
              <Card>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                    <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center' }}>
                      <ExpenseIcon color="error" sx={{ mr: 1 }} /> Categorias de Despesa
                    </Typography>
                    <Button 
                      variant="outlined" 
                      color="error" 
                      startIcon={<AddCategoryIcon />}
                      size="small"
                      onClick={() => handleOpenCategoryDialog('add', 'expense')}
                    >
                      Nova Categoria
                    </Button>
                  </Box>
                  
                  <List>
                    {expenseCategories.map(category => (
                      <ListItem key={category} divider>
                        <ListItemText primary={category} />
                        <ListItemSecondaryAction>
                          <IconButton 
                            edge="end" 
                            size="small" 
                            color="primary"
                            onClick={() => handleOpenCategoryDialog('edit', 'expense', category)}
                            sx={{ mr: 1 }}
                          >
                            <EditIcon fontSize="small" />
                          </IconButton>
                          <IconButton 
                            edge="end" 
                            size="small" 
                            color="error"
                            onClick={() => handleOpenCategoryDialog('delete', 'expense', category)}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </ListItemSecondaryAction>
                      </ListItem>
                    ))}
                  </List>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </TabPanel>
      </Box>

      {/* Modal de transação (nova ou edição) */}
      <Dialog open={openNewTransactionDialog} onClose={handleCloseNewTransactionDialog} maxWidth="sm" fullWidth>
        <DialogTitle>{currentTransaction ? 'Editar Transação' : 'Nova Transação'}</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <Grid container spacing={2}>
            <Grid item xs={12}>
              <FormControl fullWidth sx={{ mb: 2 }}>
                <InputLabel id="transaction-type-label">Tipo</InputLabel>
                <Select
                  labelId="transaction-type-label"
                  value={transactionType}
                  label="Tipo"
                  onChange={handleTransactionTypeChange}
                >
                  <MenuItem value="income">Receita</MenuItem>
                  <MenuItem value="expense">Despesa</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Descrição"
                value={transactionDescription}
                onChange={(e) => setTransactionDescription(e.target.value)}
                required
                sx={{ mb: 2 }}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Valor"
                type="number"
                value={transactionAmount}
                onChange={(e) => setTransactionAmount(e.target.value)}
                InputProps={{
                  startAdornment: <InputAdornment position="start">R$</InputAdornment>,
                }}
                required
                sx={{ mb: 2 }}
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <DatePicker
                label="Data"
                value={transactionDate}
                onChange={(newValue) => setTransactionDate(newValue)}
                slotProps={{ 
                  textField: { 
                    fullWidth: true,
                    required: true,
                    sx: { mb: 2 }
                  } 
                }}
              />
            </Grid>
            
            <Grid item xs={12} sm={9}>
              <FormControl fullWidth sx={{ mb: 2 }}>
                <InputLabel id="transaction-category-label">Categoria</InputLabel>
                <Select
                  labelId="transaction-category-label"
                  value={transactionCategory}
                  label="Categoria"
                  onChange={handleTransactionCategoryChange}
                >
                  {transactionType === 'income' ? (
                    incomeCategories.map(category => (
                      <MenuItem key={category} value={category}>{category}</MenuItem>
                    ))
                  ) : (
                    expenseCategories.map(category => (
                      <MenuItem key={category} value={category}>{category}</MenuItem>
                    ))
                  )}
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12} sm={3}>
              <Button 
                fullWidth 
                variant="outlined" 
                onClick={() => handleOpenCategoryDialog('add', transactionType === 'income' ? 'income' : 'expense')}
                sx={{ height: '56px', mb: 2 }}
              >
                Nova
              </Button>
            </Grid>
            
            <Grid item xs={12}>
              <FormControl fullWidth sx={{ mb: 2 }}>
                <InputLabel id="payment-method-label">Forma de Pagamento</InputLabel>
                <Select
                  labelId="payment-method-label"
                  value={transactionPaymentMethod}
                  label="Forma de Pagamento"
                  onChange={handleTransactionPaymentMethodChange}
                >
                  <MenuItem value="Dinheiro">Dinheiro</MenuItem>
                  <MenuItem value="Cartão de Crédito">Cartão de Crédito</MenuItem>
                  <MenuItem value="Cartão de Débito">Cartão de Débito</MenuItem>
                  <MenuItem value="PIX">PIX</MenuItem>
                  <MenuItem value="Transferência">Transferência</MenuItem>
                  <MenuItem value="Boleto">Boleto</MenuItem>
                </Select>
              </FormControl>
            </Grid>
            
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Observações"
                multiline
                rows={2}
                value={transactionNotes}
                onChange={(e) => setTransactionNotes(e.target.value)}
                sx={{ mb: 2 }}
              />
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
          <Button onClick={handleCloseNewTransactionDialog} sx={{ color: 'text.secondary' }}>
            Cancelar
          </Button>
          <Button 
            onClick={handleSaveTransaction} 
            variant="contained" 
            color={transactionType === 'income' ? 'success' : 'primary'}
          >
            {currentTransaction ? 'Atualizar' : 'Salvar'}
          </Button>
        </DialogActions>
      </Dialog>

      {/* Modal de confirmação de exclusão */}
      <Dialog
        open={openDeleteDialog}
        onClose={handleCloseDeleteDialog}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">
          Confirmar exclusão
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            Tem certeza que deseja excluir esta transação? Esta ação não pode ser desfeita.
          </DialogContentText>
          {currentTransaction && (
            <Box sx={{ mt: 2, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
              <Typography variant="subtitle2" gutterBottom>
                {currentTransaction.description}
              </Typography>
              <Typography variant="body2">
                Data: {format(new Date( currentTransaction.transaction_date), 'dd/MM/yyyy')}
              </Typography>
              <Typography variant="body2">
                Valor: R$ {currentTransaction.amount.toFixed(2)}
              </Typography>
              <Typography variant="body2">
                Tipo: {currentTransaction.type === 'income' ? 'Receita' : 'Despesa'}
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDeleteDialog} color="primary">
            Cancelar
          </Button>
          <Button onClick={handleDeleteTransaction} color="error" variant="contained" autoFocus>
            Excluir
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Modal de confirmação de exclusão de transação vinculada */}
      <Dialog
        open={openDeleteLinkedDialog}
        onClose={handleCloseDeleteLinkedDialog}
        aria-labelledby="linked-dialog-title"
        aria-describedby="linked-dialog-description"
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle id="linked-dialog-title" sx={{ color: 'error.main' }}>
          Atenção: Exclusão de Registros Vinculados
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="linked-dialog-description" paragraph>
            Esta transação está vinculada a {currentTransaction?.related_appointment_id ? 'um agendamento' : 'uma venda'} e não pode ser excluída isoladamente.
          </DialogContentText>
          
          <DialogContentText paragraph sx={{ fontWeight: 'bold' }}>
            Ao prosseguir, você excluirá:
          </DialogContentText>
          
          <Box sx={{ pl: 2, mb: 2 }}>
            {currentTransaction?.related_appointment_id && (
              <>
                <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  • O agendamento completo
                </Typography>
                <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  • Todos os serviços associados ao agendamento
                </Typography>
              </>
            )}
            
            {currentTransaction?.related_sale_id && (
              <>
                <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  • A venda completa
                </Typography>
                <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                  • Todos os itens associados à venda
                </Typography>
              </>
            )}
            
            <Typography variant="body1" sx={{ display: 'flex', alignItems: 'center' }}>
              • Esta transação financeira
            </Typography>
          </Box>
          
          <Alert severity="warning" sx={{ mb: 2 }}>
            Esta ação não pode ser desfeita e afetará múltiplos registros no sistema.
          </Alert>
          
          {currentTransaction && (
            <Box sx={{ mt: 2, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
              <Typography variant="subtitle2" gutterBottom>
                {currentTransaction.description}
              </Typography>
              <Typography variant="body2">
                Data: {format(new Date(currentTransaction.transaction_date), 'dd/MM/yyyy')}
              </Typography>
              <Typography variant="body2">
                Valor: R$ {currentTransaction.amount.toFixed(2)}
              </Typography>
              <Typography variant="body2">
                Tipo: {currentTransaction.type === 'income' ? 'Receita' : 'Despesa'}
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDeleteLinkedDialog} color="primary">
            Cancelar
          </Button>
          <Button 
            onClick={handleDeleteLinkedTransaction} 
            color="error" 
            variant="contained" 
            autoFocus
            disabled={loading}
          >
            {loading ? 'Excluindo...' : 'Excluir Todos os Registros'}
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Modal de gerenciamento de categorias */}
      <Dialog
        open={openCategoryDialog}
        onClose={handleCloseCategoryDialog}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>
          {categoryAction === 'add' && `Nova Categoria de ${categoryType === 'income' ? 'Receita' : 'Despesa'}`}
          {categoryAction === 'edit' && `Editar Categoria de ${categoryType === 'income' ? 'Receita' : 'Despesa'}`}
          {categoryAction === 'delete' && `Excluir Categoria de ${categoryType === 'income' ? 'Receita' : 'Despesa'}`}
        </DialogTitle>
        <DialogContent>
          {categoryAction === 'add' && (
            <TextField
              autoFocus
              margin="dense"
              label="Nome da Categoria"
              fullWidth
              value={newCategoryName}
              onChange={(e) => setNewCategoryName(e.target.value)}
              required
              sx={{ mt: 1 }}
            />
          )}
          
          {categoryAction === 'edit' && (
            <TextField
              autoFocus
              margin="dense"
              label="Novo Nome da Categoria"
              fullWidth
              value={editCategoryName}
              onChange={(e) => setEditCategoryName(e.target.value)}
              required
              sx={{ mt: 1 }}
            />
          )}
          
          {categoryAction === 'delete' && (
            <>
              <DialogContentText>
                Tem certeza que deseja excluir a categoria "{selectedCategory}"?
              </DialogContentText>
              <DialogContentText sx={{ mt: 2, color: 'error.main' }}>
                Nota: Só é possível excluir categorias que não estão sendo utilizadas em nenhuma transação.
              </DialogContentText>
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseCategoryDialog} color="primary">
            Cancelar
          </Button>
          {categoryAction === 'add' && (
            <Button onClick={handleAddCategory} color="primary" variant="contained">
              Adicionar
            </Button>
          )}
          {categoryAction === 'edit' && (
            <Button onClick={handleEditCategory} color="primary" variant="contained">
              Salvar
            </Button>
          )}
          {categoryAction === 'delete' && (
            <Button onClick={handleDeleteCategory} color="error" variant="contained">
              Excluir
            </Button>
          )}
        </DialogActions>
      </Dialog>

      {/* Notificação de erro */}
      <Snackbar 
        open={!!error} 
        autoHideDuration={6000} 
        onClose={() => setError('')}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert onClose={() => setError('')} severity="error">{error}</Alert>
      </Snackbar>

      {/* Notificação de sucesso */}
      <Snackbar 
        open={!!success} 
        autoHideDuration={6000} 
        onClose={() => setSuccess('')}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert onClose={() => setSuccess('')} severity="success">{success}</Alert>
      </Snackbar>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Inventory.tsx
Código:
import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  TextField, 
  Dialog, 
  DialogActions, 
  DialogContent, 
  DialogTitle, 
  IconButton, 
  InputAdornment, 
  CircularProgress, 
  Snackbar, 
  Alert,
  Grid,
  Chip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  SelectChangeEvent
} from '@mui/material';
import { 
  Add as AddIcon, 
  Search as SearchIcon, 
  Edit as EditIcon,
  TrendingUp as TrendingUpIcon,
  TrendingDown as TrendingDownIcon,
  Category as CategoryIcon
} from '@mui/icons-material';
import { supabase } from '../lib/supabase';
import { useAuth } from '../context/AuthContext';

// Interface para itens do estoque
interface InventoryItem {
  id: string;
  name: string;
  quantity: number;
  cost_price: number;
  selling_price: number;
  category: string;
  created_at: string;
  created_by: string;
}

export default function Inventory() {
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [filteredItems, setFilteredItems] = useState<InventoryItem[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [openDialog, setOpenDialog] = useState(false);
  const [openCategoryDialog, setOpenCategoryDialog] = useState(false);
  const [currentItem, setCurrentItem] = useState<InventoryItem | null>(null);
  const [itemName, setItemName] = useState('');
  const [itemQuantity, setItemQuantity] = useState('0');
  const [itemCostPrice, setItemCostPrice] = useState('0');
  const [itemSellingPrice, setItemSellingPrice] = useState('0');
  const [itemCategory, setItemCategory] = useState('Geral');
  const [newCategory, setNewCategory] = useState('');
  const [categories, setCategories] = useState<string[]>(['Geral']);
  const [categoryFilter, setCategoryFilter] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const { user } = useAuth();

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('inventory')
        .select('*')
        .order('name', { ascending: true });

      if (error) throw error;

      setInventory(data || []);
      setFilteredItems(data || []);
      
      // Extract unique categories
      const uniqueCategories = Array.from(
        new Set(data?.map(item => item.category || 'Geral') || ['Geral'])
      );
      setCategories(uniqueCategories);
    } catch (error) {
      setError('Erro ao carregar dados');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  const handleFilter = () => {
    let filtered = inventory;
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(item =>
        item.name.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by category
    if (categoryFilter) {
      filtered = filtered.filter(item => item.category === categoryFilter);
    }
    
    setFilteredItems(filtered);
  };

  useEffect(() => {
    handleFilter();
  }, [searchTerm, categoryFilter, inventory]);

  const handleOpenDialog = (item?: InventoryItem) => {
    if (item) {
      setCurrentItem(item);
      setItemName(item.name);
      setItemQuantity(item.quantity.toString());
      setItemCostPrice(item.cost_price.toString());
      setItemSellingPrice(item.selling_price.toString());
      setItemCategory(item.category || 'Geral');
    } else {
      setCurrentItem(null);
      setItemName('');
      setItemQuantity('0');
      setItemCostPrice('0');
      setItemSellingPrice('0');
      setItemCategory('Geral');
    }
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
  };

  const handleOpenCategoryDialog = () => {
    setNewCategory('');
    setOpenCategoryDialog(true);
  };

  const handleCloseCategoryDialog = () => {
    setOpenCategoryDialog(false);
  };

  const handleAddCategory = () => {
    if (newCategory && !categories.includes(newCategory)) {
      setCategories([...categories, newCategory]);
      setItemCategory(newCategory);
    }
    handleCloseCategoryDialog();
  };

  const handleCategoryChange = (event: SelectChangeEvent) => {
    setItemCategory(event.target.value);
  };

  const handleCategoryFilterChange = (event: SelectChangeEvent) => {
    setCategoryFilter(event.target.value);
  };

  const handleSaveItem = async () => {
    if (!itemName) {
      setError('Nome é obrigatório');
      return;
    }

    if (isNaN(Number(itemQuantity))) {
      setError('Quantidade inválida');
      return;
    }

    if (isNaN(Number(itemCostPrice)) || Number(itemCostPrice) < 0) {
      setError('Preço de custo inválido');
      return;
    }

    if (isNaN(Number(itemSellingPrice)) || Number(itemSellingPrice) < 0) {
      setError('Preço de venda inválido');
      return;
    }

    try {
      if (currentItem) {
        const { error } = await supabase
          .from('inventory')
          .update({ 
            name: itemName, 
            quantity: Number(itemQuantity),
            cost_price: Number(itemCostPrice),
            selling_price: Number(itemSellingPrice),
            category: itemCategory
          })
          .eq('id', currentItem.id);

        if (error) throw error;
      } else {
        const { error } = await supabase
          .from('inventory')
          .insert([{ 
            name: itemName, 
            quantity: Number(itemQuantity),
            cost_price: Number(itemCostPrice),
            selling_price: Number(itemSellingPrice),
            category: itemCategory,
            created_by: user?.id 
          }]);

        if (error) throw error;
      }

      handleCloseDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao salvar item');
      console.error(error);
    }
  };

  const calculateProfit = (costPrice: number, sellingPrice: number) => {
    if (costPrice === 0) return 0;
    return ((sellingPrice - costPrice) / costPrice) * 100;
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      {/* Cabeçalho */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" sx={{ fontWeight: 'medium' }}>
          Estoque
        </Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          onClick={() => handleOpenDialog()}
        >
          Novo Item
        </Button>
      </Box>

      {/* Resumo do estoque */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Total de Itens
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
              {inventory.reduce((sum, item) => sum + item.quantity, 0)} unidades
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Valor Total do Estoque
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
              R$ {inventory.reduce((sum, item) => sum + (item.cost_price * item.quantity), 0).toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Lucro Potencial
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
              R$ {inventory.reduce((sum, item) => 
                sum + ((item.selling_price - item.cost_price) * item.quantity), 0).toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
      </Grid>

      {/* Filtros */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} md={6}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Buscar por nome do produto..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />
          </Grid>
          <Grid item xs={12} md={6}>
            <FormControl fullWidth>
              <InputLabel id="category-filter-label">Filtrar por Categoria</InputLabel>
              <Select
                labelId="category-filter-label"
                value={categoryFilter}
                label="Filtrar por Categoria"
                onChange={handleCategoryFilterChange}
              >
                <MenuItem value="">Todas as Categorias</MenuItem>
                {categories.map((category) => (
                  <MenuItem key={category} value={category}>{category}</MenuItem>
                ))}
              </Select>
            </FormControl>
          </Grid>
        </Grid>
      </Paper>

      {/* Tabela de estoque */}
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Nome</TableCell>
              <TableCell>Categoria</TableCell>
              <TableCell align="right">Quantidade</TableCell>
              <TableCell align="right">Preço de Custo</TableCell>
              <TableCell align="right">Preço de Venda</TableCell>
              <TableCell align="right">Lucro</TableCell>
              <TableCell align="right">Ações</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {filteredItems.map((item) => {
              const profit = calculateProfit(item.cost_price, item.selling_price);
              return (
                <TableRow key={item.id}>
                  <TableCell>{item.name}</TableCell>
                  <TableCell>
                    <Chip 
                      icon={<CategoryIcon fontSize="small" />} 
                      label={item.category || 'Geral'} 
                      size="small" 
                      sx={{ 
                        backgroundColor: 'rgba(248, 187, 208, 0.2)',
                        borderRadius: '16px'
                      }} 
                    />
                  </TableCell>
                  <TableCell align="right">
                    {item.quantity}
                    {item.quantity <= 5 && (
                      <Chip 
                        label={item.quantity === 0 ? "Esgotado" : "Estoque Baixo"} 
                        color={item.quantity === 0 ? "error" : "warning"} 
                        size="small" 
                        sx={{ ml: 1 }}
                      />
                    )}
                  </TableCell>
                  <TableCell align="right">R$ {item.cost_price.toFixed(2)}</TableCell>
                  <TableCell align="right">R$ {item.selling_price.toFixed(2)}</TableCell>
                  <TableCell align="right">
                    <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end' }}>
                      {profit > 0 ? (
                        <TrendingUpIcon fontSize="small" color="success" sx={{ mr: 0.5 }} />
                      ) : (
                        <TrendingDownIcon fontSize="small" color="error" sx={{ mr: 0.5 }} />
                      )}
                      {profit.toFixed(2)}%
                    </Box>
                  </TableCell>
                  <TableCell align="right">
                    <IconButton color="primary" onClick={() => handleOpenDialog(item)}>
                      <EditIcon />
                    </IconButton>
                  </TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
      </TableContainer>

      {/* Modal de item */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>{currentItem ? 'Editar Item' : 'Novo Item'}</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <TextField
            autoFocus
            margin="dense"
            label="Nome do Produto"
            type="text"
            fullWidth
            variant="outlined"
            value={itemName}
            onChange={(e) => setItemName(e.target.value)}
            required
            sx={{ mb: 2, borderRadius: 16 }}
          />
          
          <Grid container spacing={2} sx={{ mb: 2 }}>
            <Grid item xs={9}>
              <FormControl fullWidth>
                <InputLabel id="category-label">Categoria</InputLabel>
                <Select
                  labelId="category-label"
                  value={itemCategory}
                  label="Categoria"
                  onChange={handleCategoryChange}
                >
                  {categories.map((category) => (
                    <MenuItem key={category} value={category}>{category}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={3}>
              <Button 
                variant="outlined" 
                fullWidth 
                onClick={handleOpenCategoryDialog}
                sx={{ height: '56px' }}
              >
                Nova
              </Button>
            </Grid>
          </Grid>
          
          <TextField
            margin="dense"
            label="Quantidade"
            type="number"
            fullWidth
            variant="outlined"
            value={itemQuantity}
            onChange={(e) => setItemQuantity(e.target.value)}
            sx={{ mb: 2, borderRadius: 16 }}
          />
          <Grid container spacing={2}>
            <Grid item xs={6}>
              <TextField
                margin="dense"
                label="Preço de Custo"
                type="number"
                fullWidth
                variant="outlined"
                value={itemCostPrice}
                onChange={(e) => setItemCostPrice(e.target.value)}
                InputProps={{
                  startAdornment: <InputAdornment position="start">R$</InputAdornment>,
                }}
                sx={{ borderRadius: 16 }}
              />
            </Grid>
            <Grid item xs={6}>
              <TextField
                margin="dense"
                label="Preço de Venda"
                type="number"
                fullWidth
                variant="outlined"
                value={itemSellingPrice}
                onChange={(e) => setItemSellingPrice(e.target.value)}
                InputProps={{
                  startAdornment: <InputAdornment position="start">R$</InputAdornment>,
                }}
                sx={{ borderRadius: 16 }}
              />
            </Grid>
          </Grid>
          
          {Number(itemCostPrice) > 0 && Number(itemSellingPrice) > 0 && (
            <Box sx={{ mt: 2, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
              <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                Análise de Lucro
              </Typography>
              <Grid container spacing={2}>
                <Grid item xs={6}>
                  <Typography variant="body2">
                    Lucro por unidade: 
                    <Typography component="span" fontWeight="bold" sx={{ ml: 1 }}>
                      R$ {(Number(itemSellingPrice) - Number(itemCostPrice)).toFixed(2)}
                    </Typography>
                  </Typography>
                </Grid>
                <Grid item xs={6}>
                  <Typography variant="body2">
                    Margem de lucro: 
                    <Typography 
                      component="span" 
                      fontWeight="bold" 
                      color={calculateProfit(Number(itemCostPrice), Number(itemSellingPrice)) > 0 ? 'success.main' : 'error.main'}
                      sx={{ ml: 1 }}
                    >
                      {calculateProfit(Number(itemCostPrice), Number(itemSellingPrice)).toFixed(2)}%
                    </Typography>
                  </Typography>
                </Grid>
              </Grid>
            </Box>
          )}
        </DialogContent>
        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
          <Button onClick={handleCloseDialog} sx={{ color: 'text.secondary' }}>
            Cancelar
          </Button>
          <Button 
            onClick={handleSaveItem} 
            variant="contained" 
            sx={{ 
              backgroundColor: 'primary.main', 
              '&:hover': { backgroundColor: 'primary.dark' },
              borderRadius: 16,
            }}
          >
            Salvar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Modal para adicionar nova categoria */}
      <Dialog open={openCategoryDialog} onClose={handleCloseCategoryDialog} maxWidth="xs" fullWidth>
        <DialogTitle>Nova Categoria</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Nome da Categoria"
            type="text"
            fullWidth
            variant="outlined"
            value={newCategory}
            onChange={(e) => setNewCategory(e.target.value)}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseCategoryDialog}>Cancelar</Button>
          <Button onClick={handleAddCategory} variant="contained">
            Adicionar
          </Button>
        </DialogActions>
      </Dialog>

      {/* Notificação de erro */}
      <Snackbar open={!!error} autoHideDuration={6000} onClose={() => setError('')}>
        <Alert onClose={() => setError('')} severity="error">{error}</Alert>
      </Snackbar>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Login.tsx
Código:
import { useState } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { 
  Avatar, 
  Button, 
  TextField, 
  Link, 
  Grid, 
  Box, 
  Typography, 
  Container, 
  Paper,
  Alert,
  useTheme
} from '@mui/material';
import { LockOutlined as LockOutlinedIcon } from '@mui/icons-material';
import { useAuth } from '../context/AuthContext';

export default function Login() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const { signIn } = useAuth();
  const navigate = useNavigate();
  const theme = useTheme();

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    
    if (!email || !password) {
      setError('Por favor, preencha todos os campos');
      return;
    }
    
    try {
      setError('');
      setLoading(true);
      const { error } = await signIn(email, password);
      
      if (error) {
        setError('Email ou senha incorretos');
      } else {
        navigate('/dashboard');
      }
    } catch (err) {
      setError('Falha ao fazer login. Tente novamente.');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box 
      sx={{ 
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: `linear-gradient(135deg, ${theme.palette.primary.light} 0%, ${theme.palette.secondary.light} 100%)`,
        padding: 2
      }}
    >
      <Container maxWidth="xs">
        <Paper 
          elevation={6} 
          sx={{ 
            p: 4, 
            display: 'flex', 
            flexDirection: 'column', 
            alignItems: 'center',
            borderRadius: 3,
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
            background: 'rgba(255, 255, 255, 0.95)',
            backdropFilter: 'blur(10px)',
            width: '100%'
          }}
        >
          <Avatar sx={{ 
            m: 1, 
            bgcolor: 'primary.main',
            width: 56,
            height: 56,
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)'
          }}>
            <LockOutlinedIcon fontSize="large" />
          </Avatar>
          <Typography component="h1" variant="h4" sx={{ mb: 1, fontWeight: 'bold', color: 'primary.main' }}>
            Dellas
          </Typography>
          <Typography component="h2" variant="subtitle1" sx={{ mb: 3, color: 'text.secondary' }}>
            Cabelo e Pele
          </Typography>
          
          {error && <Alert severity="error" sx={{ width: '100%', mb: 2 }}>{error}</Alert>}
          
          <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1, width: '100%' }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email"
              name="email"
              autoComplete="email"
              autoFocus
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '&:hover fieldset': {
                    borderColor: 'primary.main',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'primary.main',
                  },
                },
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Senha"
              type="password"
              id="password"
              autoComplete="current-password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '&:hover fieldset': {
                    borderColor: 'primary.main',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'primary.main',
                  },
                },
              }}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ 
                mt: 3, 
                mb: 2, 
                py: 1.5, 
                borderRadius: 2,
                fontSize: '1rem',
                fontWeight: 'bold',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                '&:hover': {
                  boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)',
                }
              }}
              disabled={loading}
            >
              {loading ? 'Entrando...' : 'Entrar'}
            </Button>
            <Grid container justifyContent="flex-end">
              <Grid item>
                <Link 
                  component={RouterLink} 
                  to="/register" 
                  variant="body2"
                  sx={{ 
                    color: 'primary.main',
                    textDecoration: 'none',
                    '&:hover': {
                      textDecoration: 'underline'
                    }
                  }}
                >
                  Não tem uma conta? Cadastre-se
                </Link>
              </Grid>
            </Grid>
          </Box>
        </Paper>
      </Container>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Register.tsx
Código:
import { useState } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import { 
  Avatar, 
  Button, 
  TextField, 
  Link, 
  Grid, 
  Box, 
  Typography, 
  Container, 
  Paper,
  Alert,
  useTheme
} from '@mui/material';
import { LockOutlined as LockOutlinedIcon } from '@mui/icons-material';
import { useAuth } from '../context/AuthContext';

export default function Register() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const { signUp } = useAuth();
  const navigate = useNavigate();
  const theme = useTheme();

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    
    if (!name || !email || !password || !confirmPassword) {
      setError('Por favor, preencha todos os campos');
      return;
    }
    
    if (password !== confirmPassword) {
      setError('As senhas não coincidem');
      return;
    }
    
    if (password.length < 6) {
      setError('A senha deve ter pelo menos 6 caracteres');
      return;
    }
    
    try {
      setError('');
      setLoading(true);
      const { error } = await signUp(email, password, name);
      
      if (error) {
        if (error.message.includes('email')) {
          setError('Este email já está em uso');
        } else {
          setError(error.message);
        }
      } else {
        navigate('/login');
      }
    } catch (err) {
      setError('Falha ao criar conta. Tente novamente.');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box 
      sx={{ 
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        background: `linear-gradient(135deg, ${theme.palette.primary.light} 0%, ${theme.palette.secondary.light} 100%)`,
        padding: 2
      }}
    >
      <Container maxWidth="xs">
        <Paper 
          elevation={6} 
          sx={{ 
            p: 4, 
            display: 'flex', 
            flexDirection: 'column', 
            alignItems: 'center',
            borderRadius: 3,
            boxShadow: '0 8px 32px rgba(0, 0, 0, 0.1)',
            background: 'rgba(255, 255, 255, 0.95)',
            backdropFilter: 'blur(10px)',
            width: '100%'
          }}
        >
          <Avatar sx={{ 
            m: 1, 
            bgcolor: 'primary.main',
            width: 56,
            height: 56,
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)'
          }}>
            <LockOutlinedIcon fontSize="large" />
          </Avatar>
          <Typography component="h1" variant="h5" sx={{ mb: 3, fontWeight: 'bold' }}>
            Criar Conta
          </Typography>
          
          {error && <Alert severity="error" sx={{ width: '100%', mb: 2 }}>{error}</Alert>}
          
          <Box component="form" onSubmit={handleSubmit} noValidate sx={{ mt: 1, width: '100%' }}>
            <TextField
              margin="normal"
              required
              fullWidth
              id="name"
              label="Nome Completo"
              name="name"
              autoComplete="name"
              autoFocus
              value={name}
              onChange={(e) => setName(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '&:hover fieldset': {
                    borderColor: 'primary.main',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'primary.main',
                  },
                },
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email"
              name="email"
              autoComplete="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '&:hover fieldset': {
                    borderColor: 'primary.main',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'primary.main',
                  },
                },
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="password"
              label="Senha"
              type="password"
              id="password"
              autoComplete="new-password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '&:hover fieldset': {
                    borderColor: 'primary.main',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'primary.main',
                  },
                },
              }}
            />
            <TextField
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirmar Senha"
              type="password"
              id="confirmPassword"
              autoComplete="new-password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              sx={{
                '& .MuiOutlinedInput-root': {
                  borderRadius: 2,
                  '&:hover fieldset': {
                    borderColor: 'primary.main',
                  },
                  '&.Mui-focused fieldset': {
                    borderColor: 'primary.main',
                  },
                },
              }}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              sx={{ 
                mt: 3, 
                mb: 2, 
                py: 1.5, 
                borderRadius: 2,
                fontSize: '1rem',
                fontWeight: 'bold',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
                '&:hover': {
                  boxShadow: '0 6px 16px rgba(0, 0, 0, 0.2)',
                }
              }}
              disabled={loading}
            >
              {loading ? 'Cadastrando...' : 'Cadastrar'}
            </Button>
            <Grid container justifyContent="flex-end">
              <Grid item>
                <Link 
                  component={RouterLink} 
                  to="/login" 
                  variant="body2"
                  sx={{ 
                    color: 'primary.main',
                    textDecoration: 'none',
                    '&:hover': {
                      textDecoration: 'underline'
                    }
                  }}
                >
                  Já tem uma conta? Faça login
                </Link>
              </Grid>
            </Grid>
          </Box>
        </Paper>
      </Container>
    </Box>
  );
}
==================================================
D:/Users/pmrv0839/Documents/Dellas_Cabelo_e_Pele/src\pages\Sales.tsx
Código:
import { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Button, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  TextField, 
  Dialog, 
  DialogActions, 
  DialogContent, 
  DialogTitle, 
  IconButton, 
  InputAdornment, 
  CircularProgress, 
  Snackbar, 
  Alert,
  Grid,
  Chip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  SelectChangeEvent,
  List,
  ListItem,
  ListItemText,
  ListItemSecondaryAction,
  Divider,
  Card,
  CardContent,
  DialogContentText
} from '@mui/material';
import { 
  Add as AddIcon, 
  Search as SearchIcon, 
  Delete as DeleteIcon,
  Receipt as ReceiptIcon,
  ShoppingCart as ShoppingCartIcon,
  RemoveCircleOutline as RemoveIcon,
  AddCircleOutline as AddItemIcon,
  Visibility as ViewIcon,
  Person as PersonIcon,
  Edit as EditIcon
} from '@mui/icons-material';
import { supabase } from '../lib/supabase';
import { useAuth } from '../context/AuthContext';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { format } from 'date-fns';

// Interfaces
interface InventoryItem {
  id: string;
  name: string;
  quantity: number;
  selling_price: number;
  category: string;
}

interface Client {
  id: string;
  name: string;
  phone: string;
}

interface CartItem {
  id: string;
  name: string;
  quantity: number;
  unit_price: number;
  total_price: number;
}

interface Sale {
  id: string;
  sale_date: string;
  total_amount: number;
  payment_method: string;
  notes: string;
  created_at: string;
  created_by: string;
  client_id?: string;
  client?: {
    name: string;
  };
  sale_items: {
    id: string;
    inventory_id: string;
    quantity: number;
    unit_price: number;
    total_price: number;
    inventory: {
      name: string;
    };
  }[];
}

export default function Sales() {
  const [inventory, setInventory] = useState<InventoryItem[]>([]);
  const [sales, setSales] = useState<Sale[]>([]);
  const [clients, setClients] = useState<Client[]>([]);
  const [filteredSales, setFilteredSales] = useState<Sale[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [startDate, setStartDate] = useState<Date | null>(null);
  const [endDate, setEndDate] = useState<Date | null>(null);
  
  const [openNewSaleDialog, setOpenNewSaleDialog] = useState(false);
  const [openSaleDetailsDialog, setOpenSaleDetailsDialog] = useState(false);
  const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
  const [openNewClientDialog, setOpenNewClientDialog] = useState(false);
  const [openEditSaleDialog, setOpenEditSaleDialog] = useState(false);
  const [selectedSale, setSelectedSale] = useState<Sale | null>(null);
  
  const [cart, setCart] = useState<CartItem[]>([]);
  const [selectedProduct, setSelectedProduct] = useState('');
  const [productQuantity, setProductQuantity] = useState(1);
  const [selectedClient, setSelectedClient] = useState('');
  const [paymentMethod, setPaymentMethod] = useState('Dinheiro');
  const [saleNotes, setSaleNotes] = useState('');
  
  // New client form
  const [newClientName, setNewClientName] = useState('');
  const [newClientPhone, setNewClientPhone] = useState('');
  
  // Edit sale form
  const [editPaymentMethod, setEditPaymentMethod] = useState('');
  const [editNotes, setEditNotes] = useState('');
  const [editClient, setEditClient] = useState('');
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const { user } = useAuth();

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      setLoading(true);
      const [inventoryData, salesData, clientsData] = await Promise.all([
        supabase
          .from('inventory')
          .select('id, name, quantity, selling_price, category')
          .order('name', { ascending: true }),
        supabase
          .from('sales')
          .select(`
            *,
            client:client_id (name),
            sale_items(
              id,
              inventory_id,
              quantity,
              unit_price,
              total_price,
              inventory(name)
            )
          `)
          .order('sale_date', { ascending: false }),
        supabase
          .from('clients')
          .select('id, name, phone')
          .order('name', { ascending: true })
      ]);

      if (inventoryData.error) throw inventoryData.error;
      if (salesData.error) throw salesData.error;
      if (clientsData.error) throw clientsData.error;

      setInventory(inventoryData.data || []);
      setSales(salesData.data || []);
      setFilteredSales(salesData.data || []);
      setClients(clientsData.data || []);
    } catch (error) {
      setError('Erro ao carregar dados');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  const handleFilter = () => {
    let filtered = sales;
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(sale => {
        const itemNames = sale.sale_items
          .map(item => item.inventory?.name?.toLowerCase() || '')
          .join(' ');
        
        const clientName = sale.client?.name?.toLowerCase() || '';
        
        return (
          itemNames.includes(searchTerm.toLowerCase()) ||
          clientName.includes(searchTerm.toLowerCase()) ||
          sale.payment_method?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          sale.notes?.toLowerCase().includes(searchTerm.toLowerCase())
        );
      });
    }
    
    // Filter by date range
    if (startDate && endDate) {
      filtered = filtered.filter(sale => {
        const saleDate = new Date(sale.sale_date);
        return saleDate >= startDate && saleDate <= endDate;
      });
    }
    
    setFilteredSales(filtered);
  };

  useEffect(() => {
    handleFilter();
  }, [searchTerm, startDate, endDate, sales]);

  const handleOpenNewSaleDialog = () => {
    setCart([]);
    setSelectedProduct('');
    setSelectedClient('');
    setProductQuantity(1);
    setPaymentMethod('Dinheiro');
    setSaleNotes('');
    setOpenNewSaleDialog(true);
  };

  const handleCloseNewSaleDialog = () => {
    setOpenNewSaleDialog(false);
  };

  const handleOpenSaleDetailsDialog = (sale: Sale) => {
    setSelectedSale(sale);
    setOpenSaleDetailsDialog(true);
  };

  const handleCloseSaleDetailsDialog = () => {
    setOpenSaleDetailsDialog(false);
    setSelectedSale(null);
  };
  
  const handleOpenDeleteDialog = (sale: Sale) => {
    setSelectedSale(sale);
    setOpenDeleteDialog(true);
  };
  
  const handleCloseDeleteDialog = () => {
    setOpenDeleteDialog(false);
  };
  
  const handleOpenNewClientDialog = () => {
    setNewClientName('');
    setNewClientPhone('');
    setOpenNewClientDialog(true);
  };
  
  const handleCloseNewClientDialog = () => {
    setOpenNewClientDialog(false);
  };
  
  const handleOpenEditSaleDialog = (sale: Sale) => {
    setSelectedSale(sale);
    setEditPaymentMethod(sale.payment_method || 'Dinheiro');
    setEditNotes(sale.notes || '');
    setEditClient(sale.client_id || '');
    setOpenEditSaleDialog(true);
  };
  
  const handleCloseEditSaleDialog = () => {
    setOpenEditSaleDialog(false);
  };

  const handleProductChange = (event: SelectChangeEvent) => {
    setSelectedProduct(event.target.value);
    setProductQuantity(1);
  };
  
  const handleClientChange = (event: SelectChangeEvent) => {
    setSelectedClient(event.target.value);
  };
  
  const handleEditClientChange = (event: SelectChangeEvent) => {
    setEditClient(event.target.value);
  };

  const handlePaymentMethodChange = (event: SelectChangeEvent) => {
    setPaymentMethod(event.target.value);
  };
  
  const handleEditPaymentMethodChange = (event: SelectChangeEvent) => {
    setEditPaymentMethod(event.target.value);
  };

  const handleAddToCart = () => {
    if (!selectedProduct || productQuantity <= 0) {
      setError('Selecione um produto e quantidade válida');
      return;
    }

    const product = inventory.find(item => item.id === selectedProduct);
    if (!product) {
      setError('Produto não encontrado');
      return;
    }

    if (productQuantity > product.quantity) {
      setError(`Quantidade indisponível. Estoque atual: ${product.quantity}`);
      return;
    }

    const existingCartItem = cart.find(item => item.id === product.id);
    
    if (existingCartItem) {
      // Update existing item
      const updatedCart = cart.map(item => {
        if (item.id === product.id) {
          const newQuantity = item.quantity + productQuantity;
          if (newQuantity > product.quantity) {
            setError(`Quantidade indisponível. Estoque atual: ${product.quantity}`);
            return item;
          }
          return {
            ...item,
            quantity: newQuantity,
            total_price: newQuantity * item.unit_price
          };
        }
        return item;
      });
      setCart(updatedCart);
    } else {
      // Add new item
      const newItem: CartItem = {
        id: product.id,
        name: product.name,
        quantity: productQuantity,
        unit_price: product.selling_price,
        total_price: productQuantity * product.selling_price
      };
      setCart([...cart, newItem]);
    }
    
    setSelectedProduct('');
    setProductQuantity(1);
  };

  const handleRemoveFromCart = (productId: string) => {
    setCart(cart.filter(item => item.id !== productId));
  };

  const handleUpdateCartItemQuantity = (productId: string, newQuantity: number) => {
    if (newQuantity <= 0) {
      handleRemoveFromCart(productId);
      return;
    }
    
    const product = inventory.find(item => item.id === productId);
    if (!product || newQuantity > product.quantity) {
      setError(`Quantidade indisponível. Estoque atual: ${product?.quantity || 0}`);
      return;
    }
    
    setCart(cart.map(item => {
      if (item.id === productId) {
        return {
          ...item,
          quantity: newQuantity,
          total_price: newQuantity * item.unit_price
        };
      }
      return item;
    }));
  };

  const calculateTotal = () => {
    return cart.reduce((sum, item) => sum + item.total_price, 0);
  };
  
  const handleSaveNewClient = async () => {
    if (!newClientName) {
      setError('Nome é obrigatório');
      return;
    }

    try {
      const { data, error } = await supabase
        .from('clients')
        .insert([{ 
          name: newClientName, 
          phone: newClientPhone || null, 
          created_by: user?.id 
        }])
        .select('id, name, phone')
        .single();

      if (error) throw error;

      setClients([...clients, data]);
      setSelectedClient(data.id);
      setSuccess('Cliente adicionado com sucesso!');
      handleCloseNewClientDialog();
    } catch (error) {
      setError('Erro ao adicionar novo cliente');
      console.error(error);
    }
  };
  
  // Phone mask function
  const handlePhoneChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    let value = e.target.value.replace(/\D/g, ''); // Remove non-digits
    
    if (value.length <= 11) {
      // Format as (XX) X XXXX-XXXX
      if (value.length > 0) {
        value = value.replace(/^(\d{2})(\d)/g, '($1) $2');
      }
      if (value.length > 4) {
        value = value.replace(/(\) \d)(\d{4})(\d)/, '$1 $2-$3');
      }
      setNewClientPhone(value);
    }
  };

  const handleCompleteSale = async () => {
    if (cart.length === 0) {
      setError('Adicione pelo menos um produto ao carrinho');
      return;
    }

    try {
      // 1. Create the sale record
      const { data: saleData, error: saleError } = await supabase
        .from('sales')
        .insert([{
          sale_date: new Date().toISOString(),
          total_amount: calculateTotal(),
          payment_method: paymentMethod,
          notes: saleNotes,
          client_id: selectedClient || null,
          created_by: user?.id
        }])
        .select('id')
        .single();

      if (saleError) throw saleError;
      
      // 2. Create sale items
      const saleItems = cart.map(item => ({
        sale_id: saleData.id,
        inventory_id: item.id,
        quantity: item.quantity,
        unit_price: item.unit_price,
        total_price: item.total_price
      }));
      
      const { error: itemsError } = await supabase
        .from('sale_items')
        .insert(saleItems);
        
      if (itemsError) throw itemsError;
      
      // 3. Update inventory quantities
      for (const item of cart) {
        const inventoryItem = inventory.find(i => i.id === item.id);
        if (inventoryItem) {
          const newQuantity = inventoryItem.quantity - item.quantity;
          
          const { error: updateError } = await supabase
            .from('inventory')
            .update({ quantity: newQuantity })
            .eq('id', item.id);
            
          if (updateError) throw updateError;
        }
      }
      
      // 4. Close dialog and refresh data
      setSuccess('Venda realizada com sucesso!');
      handleCloseNewSaleDialog();
      fetchData();
      
    } catch (error) {
      setError('Erro ao processar venda');
      console.error(error);
    }
  };
  
  const handleUpdateSale = async () => {
    if (!selectedSale) return;
    
    try {
      setLoading(true);
      
      // Update sale record
      const { error: updateError } = await supabase
        .from('sales')
        .update({
          payment_method: editPaymentMethod,
          notes: editNotes,
          client_id: editClient || null
        })
        .eq('id', selectedSale.id);
      
      if (updateError) throw updateError;
      
      // Update related financial transaction
      const { error: transactionError } = await supabase
        .from('financial_transactions')
        .update({
          payment_method: editPaymentMethod
        })
        .eq('related_sale_id', selectedSale.id);
      
      if (transactionError) {
        console.error('Error updating related transaction:', transactionError);
        // Continue even if transaction update fails
      }
      
      setSuccess('Venda atualizada com sucesso!');
      handleCloseEditSaleDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao atualizar venda');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };
  
  const handleDeleteSale = async () => {
    if (!selectedSale) return;
    
    try {
      setLoading(true);
      
      // First delete related financial transactions
      const { error: transactionError } = await supabase
        .from('financial_transactions')
        .delete()
        .eq('related_sale_id', selectedSale.id);
      
      if (transactionError) {
        console.error('Error deleting related transaction:', transactionError);
        // Continue even if transaction deletion fails
      }
      
      // Then delete sale items
      const { error: itemsError } = await supabase
        .from('sale_items')
        .delete()
        .eq('sale_id', selectedSale.id);
        
      if (itemsError) throw itemsError;
      
      // Finally delete the sale
      const { error: saleError } = await supabase
        .from('sales')
        .delete()
        .eq('id', selectedSale.id);
        
      if (saleError) throw saleError;
      
      setSuccess('Venda excluída com sucesso!');
      handleCloseDeleteDialog();
      fetchData();
    } catch (error) {
      setError('Erro ao excluir venda');
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      {/* Cabeçalho */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
        <Typography variant="h4" sx={{ fontWeight: 'medium' }}>
          Vendas
        </Typography>
        <Button 
          variant="contained" 
          startIcon={<AddIcon />}
          onClick={handleOpenNewSaleDialog}
        >
          Nova Venda
        </Button>
      </Box>

      {/* Resumo de vendas */}
      <Grid container spacing={2} sx={{ mb: 4 }}>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Total de Vendas
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
              {sales.length}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Receita Total
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
              R$ {sales.reduce((sum, sale) => sum + sale.total_amount, 0).toFixed(2)}
            </Typography>
          </Paper>
        </Grid>
        <Grid item xs={12} sm={4}>
          <Paper sx={{ p: 2, display: 'flex', flexDirection: 'column', height: '100%' }}>
            <Typography variant="subtitle2" color="text.secondary" gutterBottom>
              Ticket Médio
            </Typography>
            <Typography variant="h5" sx={{ fontWeight: 'bold' }}>
              R$ {sales.length > 0 
                ? (sales.reduce((sum, sale) => sum + sale.total_amount, 0) / sales.length).toFixed(2) 
                : '0.00'}
            </Typography>
          </Paper>
        </Grid>
      </Grid>

      {/* Filtros */}
      <Paper sx={{ p: 2, mb: 3 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item xs={12} md={4}>
            <TextField
              fullWidth
              variant="outlined"
              placeholder="Buscar vendas..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              InputProps={{
                startAdornment: (
                  <InputAdornment position="start">
                    <SearchIcon />
                  </InputAdornment>
                ),
              }}
            />
          </Grid>
          <Grid item xs={12} md={3}>
            <DatePicker
              label="Data Inicial"
              value={startDate}
              onChange={(newValue) => setStartDate(newValue)}
              slotProps={{ textField: { fullWidth: true } }}
            />
          </Grid>
          <Grid item xs={12} md={3}>
            <DatePicker
              label="Data Final"
              value={endDate}
              onChange={(newValue) => setEndDate(newValue)}
              slotProps={{ textField: { fullWidth: true } }}
            />
          </Grid>
          <Grid item xs={12} md={2}>
            <Button 
              fullWidth 
              variant="outlined" 
              onClick={() => {
                setStartDate(null);
                setEndDate(null);
                setSearchTerm('');
              }}
            >
              Limpar
            </Button>
          </Grid>
        </Grid>
      </Paper>

      {/* Tabela de vendas */}
      <TableContainer component={Paper}>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Data</TableCell>
              <TableCell>Cliente</TableCell>
              <TableCell>Itens</TableCell>
              <TableCell>Forma de Pagamento</TableCell>
              <TableCell align="right">Valor Total</TableCell>
              <TableCell align="right">Ações</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {filteredSales.length > 0 ? (
              filteredSales.map((sale) => (
                <TableRow key={sale.id}>
                  <TableCell>{format(new Date(sale.sale_date), 'dd/MM/yyyy HH:mm')}</TableCell>
                  <TableCell>
                    {sale.client ? (
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <PersonIcon fontSize="small" sx={{ mr: 1, color: 'text.secondary' }} />
                        {sale.client.name}
                      </Box>
                    ) : (
                      <Typography variant="body2" color="text.secondary">
                        Não informado
                      </Typography>
                    )}
                  </TableCell>
                  <TableCell>
                    {sale.sale_items.slice(0, 2).map(item => (
                      <div key={item.id}>
                        {item.quantity}x {item.inventory?.name}
                      </div>
                    ))}
                    {sale.sale_items.length > 2 && (
                      <Typography variant="body2" color="text.secondary">
                        +{sale.sale_items.length - 2} itens
                      </Typography>
                    )}
                  </TableCell>
                  <TableCell>{sale.payment_method}</TableCell>
                  <TableCell align="right">R$ {sale.total_amount.toFixed(2)}</TableCell>
                  <TableCell align="right">
                    <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                      <IconButton 
                        color="primary" 
                        onClick={() => handleOpenSaleDetailsDialog(sale)}
                        size="small"
                        sx={{ mr: 1 }}
                        title="Ver detalhes"
                      >
                        <ViewIcon />
                      </IconButton>
                      <IconButton 
                        color="primary" 
                        onClick={() => handleOpenEditSaleDialog(sale)}
                        size="small"
                        sx={{ mr: 1 }}
                        title="Editar venda"
                      >
                        <EditIcon />
                      </IconButton>
                      <IconButton 
                        color="error" 
                        onClick={() => handleOpenDeleteDialog(sale)}
                        size="small"
                        title="Excluir venda"
                      >
                        <DeleteIcon />
                      </IconButton>
                    </Box>
                  </TableCell>
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={6} align="center">
                  Nenhuma venda encontrada
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </TableContainer>

      {/* Modal de nova venda */}
      <Dialog open={openNewSaleDialog} onClose={handleCloseNewSaleDialog} maxWidth="md" fullWidth>
        <DialogTitle>Nova Venda</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <Grid container spacing={2}>
            {/* Produtos disponíveis */}
            <Grid item xs={12} md={7}>
              <Typography variant="subtitle1" gutterBottom>
                Adicionar Produtos
              </Typography>
              <Box sx={{ display: 'flex', mb: 2 }}>
                <FormControl fullWidth sx={{ mr: 1 }}>
                  <InputLabel id="product-label">Produto</InputLabel>
                  <Select
                    labelId="product-label"
                    value={selectedProduct}
                    label="Produto"
                    onChange={handleProductChange}
                  >
                    {inventory
                      .filter(item => item.quantity > 0)
                      .map((item) => (
                        <MenuItem key={item.id} value={item.id}>
                          {item.name} - R$ {item.selling_price.toFixed(2)} ({item.quantity} em estoque)
                        </MenuItem>
                      ))}
                  </Select>
                </FormControl>
                <TextField
                  label="Qtd"
                  type="number"
                  value={productQuantity}
                  onChange={(e) => setProductQuantity(parseInt(e.target.value) || 0)}
                  InputProps={{ inputProps: { min: 1 } }}
                  sx={{ width: '80px' }}
                />
                <Button 
                  variant="contained" 
                  onClick={handleAddToCart}
                  startIcon={<AddItemIcon />}
                  sx={{ ml: 1, whiteSpace: 'nowrap' }}
                >
                  Adicionar
                </Button>
              </Box>
              
              <Grid container spacing={2} sx={{ mb: 2 }}>
                <Grid item xs={9}>
                  <FormControl fullWidth>
                    <InputLabel id="client-label">Cliente</InputLabel>
                    <Select
                      labelId="client-label"
                      value={selectedClient}
                      label="Cliente"
                      onChange={handleClientChange}
                    >
                      <MenuItem value="">Sem cliente</MenuItem>
                      {clients.map((client) => (
                        <MenuItem key={client.id} value={client.id}>
                          {client.name}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                <Grid item xs={3}>
                  <Button 
                    variant="outlined" 
                    fullWidth 
                    onClick={handleOpenNewClientDialog}
                    startIcon={<AddIcon />}
                    sx={{ height: '56px' }}
                  >
                    Novo
                  </Button>
                </Grid>
              </Grid>
              
              <FormControl fullWidth sx={{ mt: 2 }}>
                <InputLabel id="payment-method-label">Forma de Pagamento</InputLabel>
                <Select
                  labelId="payment-method-label"
                  value={paymentMethod}
                  label="Forma de Pagamento"
                  onChange={handlePaymentMethodChange}
                >
                  <MenuItem value="Dinheiro">Dinheiro</MenuItem>
                  <MenuItem value="Cartão de Crédito">Cartão de Crédito</MenuItem>
                  <MenuItem value="Cartão de Débito">Cartão de Débito</MenuItem>
                  <MenuItem value="PIX">PIX</MenuItem>
                  <MenuItem value="Transferência">Transferência</MenuItem>
                  <MenuItem value="Boleto">Boleto</MenuItem>
                </Select>
              </FormControl>
              
              <TextField
                margin="normal"
                fullWidth
                label="Observações"
                multiline
                rows={2}
                value={saleNotes}
                onChange={(e) => setSaleNotes(e.target.value)}
              />
            </Grid>
            
            {/* Carrinho */}
            <Grid item xs={12} md={5}>
              <Card variant="outlined" sx={{ height: '100%' }}>
                <CardContent>
                  <Typography variant="subtitle1" gutterBottom sx={{ display: 'flex', alignItems: 'center' }}>
                    <ShoppingCartIcon sx={{ mr: 1 }} /> Carrinho
                  </Typography>
                  
                  {cart.length === 0 ? (
                    <Typography variant="body2" color="text.secondary" sx={{ my: 4, textAlign: 'center' }}>
                      Carrinho vazio
                    </Typography>
                  ) : (
                    <List>
                      {cart.map((item) => (
                        <div key={item.id}>
                          <ListItem>
                            <ListItemText
                              primary={item.name}
                              secondary={`R$ ${item.unit_price.toFixed(2)} x ${item.quantity} = R$ ${item.total_price.toFixed(2)}`}
                            />
                            <ListItemSecondaryAction>
                              <IconButton 
                                edge="end" 
                                size="small"
                                onClick={() => handleUpdateCartItemQuantity(item.id, item.quantity - 1)}
                              >
                                <RemoveIcon />
                              </IconButton>
                              <IconButton 
                                edge="end" 
                                size="small"
                                onClick={() => handleUpdateCartItemQuantity(item.id, item.quantity + 1)}
                                sx={{ mx: 1 }}
                              >
                                <AddItemIcon />
                              </IconButton>
                              <IconButton 
                                edge="end" 
                                size="small"
                                onClick={() => handleRemoveFromCart(item.id)}
                              >
                                <DeleteIcon />
                              </IconButton>
                            </ListItemSecondaryAction>
                          </ListItem>
                          <Divider />
                        </div>
                      ))}
                    </List>
                  )}
                  
                  <Box sx={{ mt: 2, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
                    <Typography variant="subtitle1" sx={{ fontWeight: 'bold', display: 'flex', justifyContent: 'space-between' }}>
                      <span>Total:</span>
                      <span>R$ {calculateTotal().toFixed(2)}</span>
                    </Typography>
                  </Box>
                </CardContent>
              </Card>
            </Grid>
          </Grid>
        </DialogContent>
        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
          <Button onClick={handleCloseNewSaleDialog} sx={{ color: 'text.secondary' }}>
            Cancelar
          </Button>
          <Button 
            onClick={handleCompleteSale} 
            variant="contained" 
            color="primary"
            startIcon={<ReceiptIcon />}
            disabled={cart.length === 0}
          >
            Finalizar Venda
          </Button>
        </DialogActions>
      </Dialog>

      {/* Modal de detalhes da venda */}
      <Dialog open={openSaleDetailsDialog} onClose={handleCloseSaleDetailsDialog} maxWidth="sm" fullWidth>
        <DialogTitle>Detalhes da Venda</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          {selectedSale && (
            <>
              <Grid container spacing={2} sx={{ mb: 3 }}>
                <Grid item xs={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Data da Venda
                  </Typography>
                  <Typography variant="body1">
                    {format(new Date(selectedSale.sale_date), 'dd/MM/yyyy HH:mm')}
                  </Typography>
                </Grid>
                <Grid item xs={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Forma de Pagamento
                  </Typography>
                  <Typography variant="body1">
                    {selectedSale.payment_method}
                  </Typography>
                </Grid>
                <Grid item xs={12}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Cliente
                  </Typography>
                  <Typography variant="body1">
                    {selectedSale.client ? selectedSale.client.name : 'Não informado'}
                  </Typography>
                </Grid>
              </Grid>
              
              <Typography variant="subtitle1" gutterBottom>
                Itens
              </Typography>
              <TableContainer component={Paper} variant="outlined" sx={{ mb: 3 }}>
                <Table size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell>Produto</TableCell>
                      <TableCell align="right">Qtd</TableCell>
                      <TableCell align="right">Preço Unit.</TableCell>
                      <TableCell align="right">Total</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {selectedSale.sale_items.map((item) => (
                      <TableRow key={item.id}>
                        <TableCell>{item.inventory?.name}</TableCell>
                        <TableCell align="right">{item.quantity}</TableCell>
                        <TableCell align="right">R$ {item.unit_price.toFixed(2)}</TableCell>
                        <TableCell align="right">R$ {item.total_price.toFixed(2)}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
              
              {selectedSale.notes && (
                <Box sx={{ mb: 3 }}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Observações
                  </Typography>
                  <Typography variant="body1">
                    {selectedSale.notes}
                  </Typography>
                </Box>
              )}
              
              <Box sx={{ p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
                <Typography variant="h6" sx={{ fontWeight: 'bold', display: 'flex', justifyContent: 'space-between' }}>
                  <span>Total:</span>
                  <span>R$ {selectedSale.total_amount.toFixed(2)}</span>
                </Typography>
              </Box>
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseSaleDetailsDialog}>Fechar</Button>
          <Button 
            color="primary" 
            startIcon={<EditIcon />} 
            onClick={() => {
              handleCloseSaleDetailsDialog();
              handleOpenEditSaleDialog(selectedSale!);
            }}
          >
            Editar
          </Button>
          <Button 
            color="error" 
            startIcon={<DeleteIcon />} 
            onClick={() => {
              handleCloseSaleDetailsDialog();
              handleOpenDeleteDialog(selectedSale!);
            }}
          >
            Excluir
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Modal para adicionar novo cliente */}
      <Dialog open={openNewClientDialog} onClose={handleCloseNewClientDialog} maxWidth="sm" fullWidth>
        <DialogTitle>Adicionar Novo Cliente</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          <TextField
            autoFocus
            margin="dense"
            label="Nome"
            type="text"
            fullWidth
            variant="outlined"
            value={newClientName}
            onChange={(e) => setNewClientName(e.target.value)}
            required
            sx={{ mb: 2, borderRadius: 16 }}
          />
          <TextField
            margin="dense"
            label="Telefone"
            type="tel"
            fullWidth
            variant="outlined"
            value={newClientPhone}
            onChange={handlePhoneChange}
            placeholder="(00) 0 0000-0000"
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <PersonIcon fontSize="small" color="action" />
                </InputAdornment>
              ),
            }}
            sx={{ borderRadius: 16 }}
          />
        </DialogContent>
        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
          <Button onClick={handleCloseNewClientDialog} sx={{ color: 'text.secondary' }}>
            Cancelar
          </Button>
          <Button 
            onClick={handleSaveNewClient} 
            variant="contained" 
            sx={{ 
              backgroundColor: 'primary.main', 
              '&:hover': { backgroundColor: 'primary.dark' },
              borderRadius: 16,
            }}
          >
            Salvar
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Modal de edição de venda */}
      <Dialog open={openEditSaleDialog} onClose={handleCloseEditSaleDialog} maxWidth="sm" fullWidth>
        <DialogTitle>Editar Venda</DialogTitle>
        <DialogContent sx={{ p: 3 }}>
          {selectedSale && (
            <>
              <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                Data da Venda: {format(new Date(selectedSale.sale_date), 'dd/MM/yyyy HH:mm')}
              </Typography>
              <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                Valor Total: R$ {selectedSale.total_amount.toFixed(2)}
              </Typography>
              
              <Grid container spacing={2} sx={{ mt: 2 }}>
                <Grid item xs={12}>
                  <FormControl fullWidth sx={{ mb: 2 }}>
                    <InputLabel id="edit-client-label">Cliente</InputLabel>
                    <Select
                      labelId="edit-client-label"
                      value={editClient}
                      label="Cliente"
                      onChange={handleEditClientChange}
                    >
                      <MenuItem value="">Sem cliente</MenuItem>
                      {clients.map((client) => (
                        <MenuItem key={client.id} value={client.id}>
                          {client.name}
                        </MenuItem>
                      ))}
                    </Select>
                  </FormControl>
                </Grid>
                
                <Grid item xs={12}>
                  <FormControl fullWidth sx={{ mb: 2 }}>
                    <InputLabel id="edit-payment-method-label">Forma de Pagamento</InputLabel>
                    <Select
                      labelId="edit-payment-method-label"
                      value={editPaymentMethod}
                      label="Forma de Pagamento"
                      onChange={handleEditPaymentMethodChange}
                    >
                      <MenuItem value="Dinheiro">Dinheiro</MenuItem>
                      <MenuItem value="Cartão de Crédito">Cartão de Crédito</MenuItem>
                      <MenuItem value="Cartão de Débito">Cartão de Débito</MenuItem>
                      <MenuItem value="PIX">PIX</MenuItem>
                      <MenuItem value="Transferência">Transferência</MenuItem>
                      <MenuItem value="Boleto">Boleto</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
                
                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Observações"
                    multiline
                    rows={3}
                    value={editNotes}
                    onChange={(e) => setEditNotes(e.target.value)}
                  />
                </Grid>
              </Grid>
              
              <Box sx={{ mt: 3 }}>
                <Typography variant="body2" color="text.secondary">
                  Nota: Não é possível editar os itens ou o valor total da venda. Para isso, exclua esta venda e crie uma nova.
                </Typography>
              </Box>
            </>
          )}
        </DialogContent>
        <DialogActions sx={{ p: 2, justifyContent: 'space-between' }}>
          <Button onClick={handleCloseEditSaleDialog} sx={{ color: 'text.secondary' }}>
            Cancelar
          </Button>
          <Button 
            onClick={handleUpdateSale} 
            variant="contained" 
            color="primary"
          >
            Salvar Alterações
          </Button>
        </DialogActions>
      </Dialog>
      
      {/* Modal de confirmação de exclusão */}
      <Dialog
        open={openDeleteDialog}
        onClose={handleCloseDeleteDialog}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">
          Confirmar exclusão
        </DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            Tem certeza que deseja excluir esta venda? Esta ação não pode ser desfeita e também removerá a transação financeira associada.
          </DialogContentText>
          {selectedSale && (
            <Box sx={{ mt: 2, p: 2, bgcolor: '#f5f5f5', borderRadius: 2 }}>
              <Typography variant="subtitle2" gutterBottom>
                Venda de {format(new Date(selectedSale.sale_date), 'dd/MM/yyyy HH:mm')}
              </Typography>
              <Typography variant="body2">
                Cliente: {selectedSale.client ? selectedSale.client.name : 'Não informado'}
              </Typography>
              <Typography variant="body2">
                Valor: R$ {selectedSale.total_amount.toFixed(2)}
              </Typography>
              <Typography variant="body2">
                Itens: {selectedSale.sale_items.length}
              </Typography>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDeleteDialog} color="primary">
            Cancelar
          </Button>
          <Button onClick={handleDeleteSale} color="error" variant="contained" autoFocus>
            Excluir
          </Button>
        </DialogActions>
      </Dialog>

      {/* Notificação de erro */}
      <Snackbar 
        open={!!error} 
        autoHideDuration={6000} 
        onClose={() => setError('')}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert onClose={() => setError('')} severity="error">{error}</Alert>
      </Snackbar>
      
      {/* Notificação de sucesso */}
      <Snackbar 
        open={!!success} 
        autoHideDuration={6000} 
        onClose={() => setSuccess('')}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert onClose={() => setSuccess('')} severity="success">{success}</Alert>
      </Snackbar>
    </Box>
  );
}
==================================================
